<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>如何区别进程和线程、协程的关系 | 前端山海经</title><meta name="author" content="jianmingYuan"><meta name="copyright" content="jianmingYuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程定义 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。   狭义定义：进程就是一段程序的执行过程例如启动的某个app。 广义定义：进程是一个具有独立功">
<meta property="og:type" content="article">
<meta property="og:title" content="如何区别进程和线程、协程的关系">
<meta property="og:url" content="https://yuan66-hub.github.io/bolg/2024/02/29/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%AB%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB/index.html">
<meta property="og:site_name" content="前端山海经">
<meta property="og:description" content="进程定义 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。   狭义定义：进程就是一段程序的执行过程例如启动的某个app。 广义定义：进程是一个具有独立功">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-02-29T04:10:57.000Z">
<meta property="article:modified_time" content="2024-02-29T06:37:16.573Z">
<meta property="article:author" content="jianmingYuan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/bolg/img/favicon.png"><link rel="canonical" href="https://yuan66-hub.github.io/bolg/2024/02/29/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%AB%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/bolg/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/bolg/',
  algolia: undefined,
  localSearch: {"path":"/bolg/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '如何区别进程和线程、协程的关系',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-29 14:37:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/bolg/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/bolg/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/bolg/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/bolg/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/bolg/" title="前端山海经"><span class="site-name">前端山海经</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/bolg/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">如何区别进程和线程、协程的关系</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-29T04:10:57.000Z" title="发表于 2024-02-29 12:10:57">2024-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-29T06:37:16.573Z" title="更新于 2024-02-29 14:37:16">2024-02-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="如何区别进程和线程、协程的关系"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
</blockquote>
<ul>
<li>狭义定义：进程就是一段程序的执行过程例如启动的某个app。</li>
<li>广义定义：进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它是<code>操作系统动态执行的基本单元</code>，在传统的操作系统中,进程即是基本的分配单元，也是基本的执行单元。</li>
</ul>
<p><code>1.进程(process)最小的资源管理单元[操作系统] 2.应用程序的启动实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间</code></p>
<p>进程的生命周期基本由操作系统内核进行支配，即进程的创建、切换、销毁等操作都将使会陷入内核，进行系统调用。该操作消耗较大。当进行进程的销毁时，包含但不仅于内存地址空间、内核态堆栈和硬件上下文(CPU寄存器)的切换甚至在内存资源较少的情况下会将已存入内存的数据写入磁盘交换区，代价较大。因此，我们可以发现当系统运行的进程越多，系统越是卡顿。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>每个进程都有自己的地址空间，一般情况下，包含文本区域、数据区域、堆栈</li>
<li>进程是执行中的程序，程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称之为进程</li>
<li>进程本身不会运行，是线程的容器。线程不能单独执行，必须组成进程</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>对于操作系统来讲，一个任务就是一个进程，比如开一个浏览器就是启动一个浏览器进程。打开一款app就是打开一个进程。</li>
<li>有些进程还不止同时做一件事情。在一个进程内部，可以同时做多件事情，比如边看视频可以边发弹幕。</li>
</ul>
<h3 id="进程状态：（三状态）"><a href="#进程状态：（三状态）" class="headerlink" title="进程状态：（三状态）"></a>进程状态：（三状态）</h3><ul>
<li>就绪：获取CPU外的所有资源、只要处理器分配资源就可以马上执行</li>
<li>运行：获得处理器分配的资源，程序开始执行</li>
<li>阻塞：当程序条件不够的时候，需要等待提交满足的时候才能执行。</li>
</ul>
<h3 id="状态详解"><a href="#状态详解" class="headerlink" title="状态详解"></a>状态详解</h3><ul>
<li>创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，<code>完成资源分配</code>。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</li>
<li>就绪状态：进程已经准备好，<code>已分配到所需资源，只要分配到CPU就能够立即运行</code></li>
<li>执行状态：进程<code>处于就绪状态被调度后，进程进入执行状态</code></li>
<li>阻塞状态：正在执行的进程由于某些事件（I&#x2F;O请求，申请缓存区失败）而暂时无法运行，<code>进程受到阻塞</code>。在满足请求时进入就绪状态等待系统调用</li>
<li>终止状态：<code>进程结束，或出现错误，或被系统终止</code>，进入终止状态。无法再执行</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
</blockquote>
<p><code>1.线程(thread)最小的执行单元[操作系统] 2.一个进程包含多个线程(一主多从),拥有自己的栈空间</code></p>
<h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ul>
<li>一个进程中至少有一个线程，不然就没有存在的意义</li>
<li>在一个进程内部，要同时干多件事情，就需要同时运行多个子任务，我们把进程内的这些子任务叫做线程</li>
<li>多线程就是为了同步完成多项任务(在单个程序中同时运行多个线程完成不同的任务和工作)，是为了提高资源使用效率来提高系统的效率，而不是为了提高运行效率。</li>
<li>一个简单的比喻，多线程就像是给车保养的工人有洗车工有维修有美容的，而进程就是待被清洗维护美容店车</li>
<li>线程是程序执行流的最小单元。一个标准的线程由当前的线程ID、当前指令指针、寄存器和堆栈组成</li>
<li>同一个进程中的多个线程之间可以并发执行</li>
</ul>
<h3 id="线程状态："><a href="#线程状态：" class="headerlink" title="线程状态："></a>线程状态：</h3><ul>
<li>就绪：指线程具备运行的所有条件，逻辑上可以运行，在等待处理机</li>
<li>运行：指线程占用处理机正在运行</li>
<li>阻塞：线程在等待一个事件，逻辑上不可执行</li>
</ul>
<h3 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h3><ul>
<li><p>进程是操作系统资源分配的<code>基本单位</code>，而线程是任务调度和执行的基本单位</p>
<p>线程和进程的实现在操作系统之间有所不同，但在大多数情况下，线程是进程的一个组件。进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。在操作系统中能同时运行多个进程；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。</p>
</li>
<li><p>进程拥有独立的<code>内存空间</code>，线程则共享所在进程中的内存空间</p>
<p>进程是系统中独立存在的实体，它可以拥有自己独立的资源，系统在运行的时候会为每个进程分配不同的内存空间，所以每一个进程都拥有自己私有的内存空间。在没有经过进程本身允许的情况下，一个用户的进程不可以直接访问其它进程的内存空间。而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），一个进程中的多个线程之间只能共享进程的资源。而不同的进程不共享这些资源。</p>
</li>
<li><p>进程之间切换开销较大，而线程间切换<code>开销</code>较小</p>
<p>每个进程都有独立的数据空间（程序上下文），进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程的切换的消耗随略小于进程，较少进行内存和磁盘的交换，但是仍然会有堆栈的映射和切换。</p>
</li>
<li><p>程序是一个静态<code>指令的集合</code>，而进程是一个正在系统中活动的指令集合</p>
<p>进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态，这写概念在程序中是不具备的。</p>
</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的<strong>轻量级线程</strong>，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。</p>
<p><code>1.协程(Coroutines)特殊的函数[程序控制] 2.一个线程可以拥有多个协程 3.可以暂停执行（暂停的表达式称为暂停点) 4.可以从挂起点恢复（保留其原始参数和局部变量） 5.事件循环是异步编程的底层基石</code></p>
<p>从名字可以看出，协程的粒度比线程更小，并且是用户管理和控制的，多个协程可以运行在一个线程上面。那么协程出现的背景又是什么呢，先来看一下目前线程中影响性能的特性：</p>
<ul>
<li>使用锁机制</li>
<li>线程间的上下文切换</li>
<li>线程运行和阻塞状态的切换</li>
</ul>
<p>以上任意一点都是很消耗cpu性能的。相对来说协程是由程序自身控制，没有线程切换的开销，且不需要锁机制，因为在同一个线程中运行，不存在同时写变量冲突，在协程中操作共享资源不加锁，只需要判断状态就行了，所以执行效率比线程高的多。</p>
<h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p>
<ul>
<li><p>对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p>
</li>
<li><p>对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）</p>
</li>
</ul>
<h3 id="协程的优点："><a href="#协程的优点：" class="headerlink" title="协程的优点："></a>协程的优点：</h3><ol>
<li>无需线程上下文切换的开销，goroutine(协程) 切换调度开销方面远比线程小。</li>
<li>无需原子操作锁定及同步的开销</li>
<li>方便切换控制流，简化编程模型</li>
<li>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。goroutine：2KB（官方），线程：8MB（参考网络）</li>
</ol>
<p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p>
<h3 id="协程的缺点："><a href="#协程的缺点：" class="headerlink" title="协程的缺点："></a>协程的缺点：</h3><ol>
<li>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li>
<li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</li>
</ol>
<p><strong>CPU密集型代码(各种循环处理、计算等等)：使用多进程。IO密集型代码(文件处理、网络爬虫等)：使用多线程</strong></p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><strong>并发与并行</strong></h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。</p>
<p>当有多个线程时，如果系统只有一个CPU，那么CPU不可能真正同时进行多个线程，CPU的运行时间会被划分成若干个时间段，每个时间段分配给各个线程去执行，一个时间段里某个线程运行时，其他线程处于挂起状态，这就是并发。并发解决了程序排队等待的问题，如果一个程序发生阻塞，其他程序仍然可以正常执行。</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。</p>
<h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ol>
<li>并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。</li>
<li>在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。</li>
</ol>
<p>知乎上高赞例子：</p>
<ul>
<li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li>
<li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li>
<li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li>
</ul>
<p>并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是 <strong>『同时』</strong>。</p>
<h2 id="JavaScript中的协程"><a href="#JavaScript中的协程" class="headerlink" title="JavaScript中的协程"></a>JavaScript中的协程</h2><h3 id="JavaScript-协程的发展"><a href="#JavaScript-协程的发展" class="headerlink" title="JavaScript 协程的发展"></a>JavaScript 协程的发展</h3><ul>
<li>同步代码</li>
<li>异步JavaScript: callback hell（回调地狱）</li>
<li>ES6引入 Promise&#x2F;a+, 生成器Generators(语法 _<em>function</em> foo(){}_*  可以赋予函数执行暂停&#x2F;保存上下文&#x2F;恢复执行状态的功能), 新关键词yield使生成器函数暂停.</li>
<li>ES7引入 async函数&#x2F;await语法糖,async可以声明一个异步函数(将Generator函数和自动执行器，包装在一个函数里)，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果,</li>
</ul>
<p>Promise中也利用了回调函数。在then和catch方法中都传入了一个回调函数，分别在Promise被满足和被拒绝时执行, 这样就就能让它能够被链接起来完成一系列任务。总之就是把层层嵌套的 callback 变成 .then().then()…，从而使代码编写和阅读更直观</p>
<p>生成器Generator的底层实现机制是协程Coroutine。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo start&quot;</span>)     a = <span class="keyword">yield</span> <span class="number">1</span>;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo a&quot;</span>, a)     <span class="keyword">yield</span> <span class="number">2</span>;     <span class="keyword">yield</span> <span class="number">3</span>;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo end&quot;</span>) &#125; <span class="keyword">const</span> gen = <span class="title function_">foo</span>(); <span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1 // gen.send(&quot;a&quot;) // http://www.voidcn.com/article/p-syzbwqht-bvv.html SpiderMonkey引擎支持 send 语法 console.log(gen.next().value); // 2 console.log(gen.next().value); // 3 console.log(foo().next().value); // 1 console.log(foo().next().value); // 1 /* foo start 1 foo a undefined 2 3 foo start 1 foo start 1 */</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-协程成熟体"><a href="#JavaScript-协程成熟体" class="headerlink" title="JavaScript 协程成熟体"></a>JavaScript 协程成熟体</h3><h4 id="Promise继续使用"><a href="#Promise继续使用" class="headerlink" title="Promise继续使用"></a>Promise继续使用</h4><p>Promise 本质是一个状态机，用于表示一个异步操作的最终完成 (或失败), 及其结果值。它有三个状态：</p>
<ul>
<li>pending: 初始状态，既不是成功，也不是失败状态。</li>
<li>fulfilled: 意味着操作成功完成。</li>
<li>rejected: 意味着操作失败。</li>
</ul>
<p>最终 Promise 会有两种状态，一种成功，一种失败，当 pending 变化的时候，Promise 对象会根据最终的状态调用不同的处理函数。</p>
<h4 id="async、await语法糖"><a href="#async、await语法糖" class="headerlink" title="async、await语法糖"></a>async、await语法糖</h4><p>async、await 是对 Generator 和 Promise 组合的封装, 使原先的异步代码在形式上更接近同步代码的写法,并且对错误处理&#x2F;条件分支&#x2F;异常堆栈&#x2F;调试等操作更友好。Async、Await 实现了 Generator 的自动迭代，正因为 Async、Await 是对 Generator 和 Promise 组合的封装，所以 Async 和 Await 基本上就只能用来实现异步和并发了，而不具有协程的其他作用。</p>
<h3 id="JavaScript-异步执行的运行机制"><a href="#JavaScript-异步执行的运行机制" class="headerlink" title="JavaScript 异步执行的运行机制"></a>JavaScript 异步执行的运行机制</h3><ol>
<li>所有任务都在主线程上执行，形成一个执行栈。\</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。\</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。</li>
</ol>
<p>遇到同步任务直接执行,遇到异步任务分类为宏任务(macro-task)和微任务(micro-task)。<br>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sleep = <span class="keyword">function</span> (<span class="params">time</span>) &#123;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sleep start&quot;</span>)     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;         <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;             <span class="title function_">resolve</span>();         &#125;, time);     &#125;); &#125;; <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">exec</span>(<span class="params"></span>) &#123;     <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">2000</span>);     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sleep end&quot;</span>) &#125; <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params"></span>) &#123;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>())     c1 = <span class="title function_">exec</span>()     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------1&quot;</span>)     c2 = <span class="title function_">exec</span>()     <span class="variable language_">console</span>.<span class="title function_">log</span>(c1, c2)     <span class="keyword">await</span> c1;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------2&quot;</span>)     <span class="keyword">await</span> c2;     <span class="variable language_">console</span>.<span class="title function_">log</span>(c1, c2)     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>()) &#125; <span class="title function_">go</span>();</span><br></pre></td></tr></table></figure>

<h3 id="event-loop将任务划分："><a href="#event-loop将任务划分：" class="headerlink" title="event loop将任务划分："></a>event loop将任务划分：</h3><ul>
<li>主线程循环从”任务队列”中读取事件</li>
<li>宏队列（macro task）js同步执行的代码块，setTimeout、setInterval、XMLHttprequest、setImmediate、I&#x2F;O、UI rendering等, 本质是参与了事件循环的任务.</li>
<li>微队列（micro task）Promise、process.nextTick（node环境）、Object.observe, MutationObserver等,本质是直接在 Javascript 引擎中的执行的没有参与事件循环的任务.</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h2><ol>
<li>线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。</li>
<li>对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。</li>
<li>所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</li>
</ol>
<p>总结：进程、线程和协程的设计，都是为了并发任务能够更好的利用CPU资源，他们最大的区别即在于对CPU的使用上(任务调度)：如前文所述，进程和线程的任务调度由内核控制，是抢占式的；而协程的任务调度在用户态完成，需要在代码里显式的把CPU交给其他协程，是协作式的。</p>
<p>由于我们可以在用户态调度协程任务，所以，我们可以把一组互相依赖的任务设计成协程。这样，当一个协程任务完成之后，可以手动进行任务调度，把自己挂起(yield)，切换到另外一个协程执行。这样，由于我们可以控制程序主动让出资源，很多情况下将不需要对资源加锁。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuan66-hub.github.io/bolg">jianmingYuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuan66-hub.github.io/bolg/2024/02/29/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%AB%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB/">https://yuan66-hub.github.io/bolg/2024/02/29/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%AB%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yuan66-hub.github.io/bolg" target="_blank">前端山海经</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/bolg/2024/03/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/" title="神经网络入门"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/bolg/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">神经网络入门</div></div></a></div><div class="next-post pull-right"><a href="/bolg/2024/02/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20CSS%20%E4%B9%8B%E5%8C%85%E5%90%AB%E5%9D%97/" title="你不知道的 CSS 之包含块"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/bolg/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">你不知道的 CSS 之包含块</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/bolg/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">jianmingYuan</div><div class="author-info__description">野生技术爱好者</div></div><div class="card-info-data site-data is-center"><a href="/bolg/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/bolg/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/bolg/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text">特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9A%EF%BC%88%E4%B8%89%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">进程状态：（三状态）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">状态详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81-1"><span class="toc-number">2.2.</span> <span class="toc-text">特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">线程状态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">2.4.</span> <span class="toc-text">进程与线程对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81-2"><span class="toc-number">3.2.</span> <span class="toc-text">特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">3.3.</span> <span class="toc-text">协程的优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">3.4.</span> <span class="toc-text">协程的缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">4.</span> <span class="toc-text">并发与并行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">4.1.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-number">4.2.</span> <span class="toc-text">并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">并发与并行的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">JavaScript中的协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">5.1.</span> <span class="toc-text">JavaScript 协程的发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E5%8D%8F%E7%A8%8B%E6%88%90%E7%86%9F%E4%BD%93"><span class="toc-number">5.2.</span> <span class="toc-text">JavaScript 协程成熟体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">Promise继续使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async%E3%80%81await%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">5.2.2.</span> <span class="toc-text">async、await语法糖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">JavaScript 异步执行的运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#event-loop%E5%B0%86%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86%EF%BC%9A"><span class="toc-number">5.4.</span> <span class="toc-text">event loop将任务划分：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.</span> <span class="toc-text">最佳实践</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/bolg/2024/03/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3vite%E5%8E%9F%E7%90%86/" title="深入理解vite原理"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/bolg/img/404.jpg'" alt="深入理解vite原理"/></a><div class="content"><a class="title" href="/bolg/2024/03/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3vite%E5%8E%9F%E7%90%86/" title="深入理解vite原理">深入理解vite原理</a><time datetime="2024-03-06T02:18:39.000Z" title="发表于 2024-03-06 10:18:39">2024-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bolg/2024/03/04/Moudle-%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99/" title="Moudle 加载规则"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/bolg/img/404.jpg'" alt="Moudle 加载规则"/></a><div class="content"><a class="title" href="/bolg/2024/03/04/Moudle-%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99/" title="Moudle 加载规则">Moudle 加载规则</a><time datetime="2024-03-04T08:22:00.000Z" title="发表于 2024-03-04 16:22:00">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bolg/2024/03/01/js%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/" title="js如何管理内存"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/bolg/img/404.jpg'" alt="js如何管理内存"/></a><div class="content"><a class="title" href="/bolg/2024/03/01/js%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/" title="js如何管理内存">js如何管理内存</a><time datetime="2024-03-01T09:27:53.000Z" title="发表于 2024-03-01 17:27:53">2024-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bolg/2024/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" title="深入理解防抖和节流"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/bolg/img/404.jpg'" alt="深入理解防抖和节流"/></a><div class="content"><a class="title" href="/bolg/2024/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" title="深入理解防抖和节流">深入理解防抖和节流</a><time datetime="2024-03-01T08:47:56.000Z" title="发表于 2024-03-01 16:47:56">2024-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bolg/2024/03/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/" title="神经网络入门"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/bolg/img/404.jpg'" alt="神经网络入门"/></a><div class="content"><a class="title" href="/bolg/2024/03/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/" title="神经网络入门">神经网络入门</a><time datetime="2024-03-01T07:04:38.000Z" title="发表于 2024-03-01 15:04:38">2024-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By jianmingYuan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/bolg/js/utils.js"></script><script src="/bolg/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/bolg/js/search/local-search.js"></script></div></div></body></html>