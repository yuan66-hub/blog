<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Moudle 加载规则</title>
    <url>/bolg/2024/03/04/Moudle-%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h1><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// module code</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p>
<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>
<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p>
<h2 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h2><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。</p>
<p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。</p>
<p><code>&lt;script&gt;</code>标签的<code>async</code>属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>举例来说，jQuery 就支持模块加载。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;./jquery/src/jquery.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  $(<span class="string">&#x27;#message&#x27;</span>).<span class="title function_">text</span>(<span class="string">&#x27;Hi from jQuery!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>下面是一个示例模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;https://example.com/js/utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x === <span class="variable language_">window</span>.<span class="property">x</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="variable language_">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><ul>
<li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案</li>
<li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块；采取依赖前置的方案，提前执行</li>
<li>CMD规范与AMD规范很相似，都用于浏览器编程，采取依赖就近的方案，延迟执行</li>
<li>UMD的出现是为了让模块同时兼容<code>CommonJs、CMD</code> 甚至是 <code>AMD</code> 的规范</li>
<li>ES6 在<strong>语言标准的层面</strong>上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>
</ul>
<table>
<thead>
<tr>
<th>规范</th>
<th>使用场景</th>
<th>模块加载方案</th>
<th>实现模块规范</th>
<th>引用模块</th>
<th>导出接口</th>
</tr>
</thead>
<tbody><tr>
<td>CommonJS</td>
<td>服务端</td>
<td>同步加载模块，运行时确认模块依赖关系</td>
<td>NodeJS</td>
<td>require（）</td>
<td>module.exports</td>
</tr>
<tr>
<td>AMD</td>
<td>浏览器</td>
<td>异步加载模块，运行时确认模块依赖关系，尽可能的懒加载，也称为延迟加载，即在需要的时候才加载（依赖前置）</td>
<td>RequireJS</td>
<td>require（）</td>
<td>define（）函数返回值 return {}</td>
</tr>
<tr>
<td>CMD</td>
<td>浏览器</td>
<td>异步加载模块，运行时确认模块依赖关系，执行过程中会将所有依赖前置执行，即在代码逻辑开始前全部执行（依赖就近）</td>
<td>SeaJS</td>
<td>require（）</td>
<td>exports</td>
</tr>
<tr>
<td>ESM</td>
<td>服务端和浏览器</td>
<td>异步加载模块，编译时确认模块依赖关系</td>
<td>原生JS</td>
<td>import（）</td>
<td>export</td>
</tr>
</tbody></table>
<h1 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h1><p>讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</p>
<p>它们有三个重大差异。</p>
<ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
<li>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</li>
</ul>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>下面重点解释第一个差异。</p>
<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mod.<span class="property">counter</span>);  <span class="comment">// 3</span></span><br><span class="line">mod.<span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mod.<span class="property">counter</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">counter</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<p>还是举上面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p>
<p>再举一个出现在<code>export</code>一节中的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(foo), <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了 500 毫秒，又变为等于<code>baz</code>。</p>
<p>让我们看看，<code>m2.js</code>能否正确读取这个变化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ babel-node m2.js</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>

<p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p>
<p>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">prop</span> = <span class="number">123</span>; <span class="comment">// OK</span></span><br><span class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。</p>
<p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sum</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sum</span> += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">show</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sum</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br></pre></td></tr></table></figure>

<p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">&#x27;./mod&#x27;</span>;</span><br><span class="line">c.<span class="title function_">add</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// y.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">&#x27;./mod&#x27;</span>;</span><br><span class="line">c.<span class="title function_">show</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./x&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./y&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>现在执行<code>main.js</code>，输出的是<code>1</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ babel-node main.js</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例。</p>
<h2 id="Node-js-的模块加载方法"><a href="#Node-js-的模块加载方法" class="headerlink" title="Node.js 的模块加载方法"></a>Node.js 的模块加载方法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。</p>
<p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p>
<p>它们采用不同的加载方案。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。</p>
<p>Node.js 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。Node.js 遇到<code>.mjs</code>文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p>
<p>如果不希望将后缀名改成<code>.mjs</code>，可以在项目的<code>package.json</code>文件中，指定<code>type</code>字段为<code>module</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦设置了以后，该项目的 JS 脚本，就被解释成 ES6 模块。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解释成 ES6 模块</span></span><br><span class="line">$ node my-app.js</span><br></pre></td></tr></table></figure>

<p>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</p>
<p>总结为一句话：<code>.mjs</code>文件总是以 ES6 模块加载，<code>.cjs</code>文件总是以 CommonJS 模块加载，<code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</p>
<p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p>
<h3 id="package-json-的-main-字段"><a href="#package-json-的-main-字段" class="headerlink" title="package.json 的 main 字段"></a>package.json 的 main 字段</h3><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p>
<p>然后，<code>import</code>命令就可以加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;es-module-package&#x27;</span>;</span><br><span class="line"><span class="comment">// 实际加载的是 ./node_modules/es-module-package/src/index.js</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p>
<p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p>
<h3 id="package-json-的-exports-字段"><a href="#package-json-的-exports-字段" class="headerlink" title="package.json 的 exports 字段"></a>package.json 的 exports 字段</h3><p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p>
<p>（1）子目录别名</p>
<p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./submodule&quot;</span>: <span class="string">&quot;./src/submodule.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码指定<code>src/submodule.js</code>别名为<code>submodule</code>，然后就可以从别名加载这个文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/submodule&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br></pre></td></tr></table></figure>

<p>下面是子目录别名的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./features/&quot;</span>: <span class="string">&quot;./src/features/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feature <span class="keyword">from</span> <span class="string">&#x27;es-module-package/features/x.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span></span><br></pre></td></tr></table></figure>

<p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/private-module.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;./node_modules/es-module-package/private-module.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>（2）main 的别名</p>
<p><code>exports</code>字段的别名如果是<code>.</code>，就代表模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./main-legacy.cjs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main-modern.cjs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p>
<p><strong>（3）条件加载</strong></p>
<p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，别名<code>.</code>的<code>require</code>条件指定<code>require()</code>命令的入口文件（即 CommonJS 的入口），<code>default</code>条件指定其他情况的入口（即 ES6 的入口）。</p>
<p>上面的写法可以简写如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果同时还有其他别名，就不能采用简写，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./feature&quot;</span>: <span class="string">&quot;./lib/feature.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h3><p>CommonJS 的<code>require()</code>命令不能加载 ES6 模块，会报错，只能使用<code>import()</code>这个方法加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-app.mjs&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上面代码可以在 CommonJS 模块中运行。</p>
<p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p>
<h3 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h3><p>ES6 模块的<code>import</code>命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">import</span> packageMain <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; method &#125; <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是<code>module.exports</code>，是一个对象，无法被静态分析，所以只能整体加载。</p>
<p>加载单一的输出项，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> packageMain <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; method &#125; = packageMain;</span><br></pre></td></tr></table></figure>

<p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cjs.cjs</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;cjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// esm.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="title function_">createRequire</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">&#x27;./cjs.cjs&#x27;</span>);</span><br><span class="line">cjs === <span class="string">&#x27;cjs&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p>
<h3 id="同时支持两种格式的模块"><a href="#同时支持两种格式的模块" class="headerlink" title="同时支持两种格式的模块"></a>同时支持两种格式的模块</h3><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p>
<p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p>
<p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">&#x27;../index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = cjsModule.<span class="property">foo</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p>
<p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p>
<p>另一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;exports&quot;</span>：&#123;</span><br><span class="line">  <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./index.js&quot;</span>，</span><br><span class="line">  <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./esm/wrapper.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p>
<h3 id="Node-js-的内置模块"><a href="#Node-js-的内置模块" class="headerlink" title="Node.js 的内置模块"></a>Node.js 的内置模块</h3><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">EventEmitter</span> <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定的输出项</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;./foo.txt&#x27;</span>, <span class="function">(<span class="params">err, source</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h3><p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 模块中将报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo.mjs?query=1&#x27;</span>; <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p>
<p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p>
<h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p>
<p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p>
<p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p>
<ul>
<li><code>arguments</code></li>
<li><code>require</code></li>
<li><code>module</code></li>
<li><code>exports</code></li>
<li><code>__filename</code></li>
<li><code>__dirname</code></li>
</ul>
<h2 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h2><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p>
<p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p>
<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p>
<h3 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h3><p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。</p>
<p>CommonJS 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">exports</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">loaded</span>: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p>
<p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p>
<h3 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<p>让我们来看，Node <a href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a>里面的例子。脚本文件<code>a.js</code>代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.<span class="property">done</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p>
<p>再看<code>b.js</code>的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.<span class="property">done</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p>
<p><code>a.js</code>已经执行的部分，只有一行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p>
<p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.<span class="property">done</span>, b.<span class="property">done</span>);</span><br></pre></td></tr></table></figure>

<p>执行<code>main.js</code>，运行结果如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p>
<p>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>).<span class="property">foo</span>; <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">good</span> = <span class="keyword">function</span> (<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="title function_">foo</span>(<span class="string">&#x27;good&#x27;</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bad</span> = <span class="keyword">function</span> (<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">foo</span>(<span class="string">&#x27;bad&#x27;</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p>
<h3 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>请看下面这个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>

<p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p>
<p>让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</p>
<p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>());</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>());</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure>

<p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

<p>这是因为函数具有提升作用，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>());</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p>
<p>我们再来看 ES6 模块加载器<a href="https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md">SystemJS</a>给出的一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">&#x27;./odd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">even</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || <span class="title function_">odd</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">&#x27;./even&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">odd</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; <span class="title function_">even</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p>
<p>运行上面这段代码，结果如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./even.js&#x27;</span>;</span><br><span class="line">&gt; m.<span class="title function_">even</span>(<span class="number">10</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.<span class="property">counter</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; m.<span class="title function_">even</span>(<span class="number">20</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.<span class="property">counter</span></span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p>
<p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">&#x27;./odd&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">counter</span> = counter;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">even</span> = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || <span class="title function_">odd</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">&#x27;./even&#x27;</span>).<span class="property">even</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; <span class="title function_">even</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m = require(<span class="string">&#x27;./even&#x27;</span>);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>js如何管理内存</title>
    <url>/bolg/2024/03/01/js%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>JS的内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。<br>其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。</p>
<h1 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h1><ol>
<li>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。</li>
<li>栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。</li>
<li>由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。</li>
<li>为了得到栈底的元素，必须先拿掉上面的元素。</li>
</ol>
<h1 id="堆数据结构"><a href="#堆数据结构" class="headerlink" title="堆数据结构"></a>堆数据结构</h1><ol>
<li>堆是一种经过排序的树形数据结构，每个结点都有一个值。</li>
<li>通常我们所说的堆的数据结构，是指二叉堆。</li>
<li>堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。</li>
<li>由于堆的这个特性，常用来实现优先队列，堆的存取是随意</li>
</ol>
<p>这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，我们只需要关心书的名字。</p>
<h1 id="变量类型与内存的关系"><a href="#变量类型与内存的关系" class="headerlink" title="变量类型与内存的关系"></a>变量类型与内存的关系</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型共有6种：</p>
<ol>
<li>Sting</li>
<li>Number</li>
<li>Boolean</li>
<li>null</li>
<li>undefined</li>
<li>Symbol</li>
</ol>
<blockquote>
<p>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。</p>
</blockquote>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ol>
<li>Array</li>
<li>Function</li>
<li>Object</li>
</ol>
<blockquote>
<p>引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
</blockquote>
<h2 id="栈内存和堆内存的优缺点"><a href="#栈内存和堆内存的优缺点" class="headerlink" title="栈内存和堆内存的优缺点"></a>栈内存和堆内存的优缺点</h2><ul>
<li>在JS中，基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。</li>
<li>引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。</li>
<li>栈内存由于它的特点，所以它的系统效率较高。</li>
<li>堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。</li>
</ul>
<h2 id="栈内存和堆内存的垃圾回收"><a href="#栈内存和堆内存的垃圾回收" class="headerlink" title="栈内存和堆内存的垃圾回收"></a>栈内存和堆内存的垃圾回收</h2><p>栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。</p>
<h2 id="闭包与堆内存"><a href="#闭包与堆内存" class="headerlink" title="闭包与堆内存"></a>闭包与堆内存</h2><p>闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量。举一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">A</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。 现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p>
<h1 id="深克隆和浅克隆"><a href="#深克隆和浅克隆" class="headerlink" title="深克隆和浅克隆"></a>深克隆和浅克隆</h1><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><ol>
<li>浅拷贝只复制对象的第一层属性。如果对象的属性值是基本数据类型（如String、Number、Boolean等），则直接复制值；如果属性值是引用类型（如Array、Object等），则复制其内存地址，而不是复制实际的值或嵌套的对象。以下都是浅拷贝的实现：</li>
</ol>
<ul>
<li><p>Object.assign()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> origin = &#123; <span class="attr">a</span>: <span class="string">&#x27;原始字符串&#x27;</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, origin);</span><br><span class="line">origin.<span class="property">a</span> = <span class="string">&#x27;改变后的字符串&#x27;</span>;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(origin); <span class="comment">// &#123;a: &#x27;改变后的字符串&#x27;, b: &#123;c: 2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123;a: &#x27;原始字符串&#x27;, b: &#123;c: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>扩展运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> origin = &#123; <span class="attr">a</span>: <span class="string">&#x27;原始字符串&#x27;</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = &#123; ...origin &#125;;</span><br><span class="line">origin.<span class="property">a</span> = <span class="string">&#x27;改变后的字符串&#x27;</span>;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(origin); <span class="comment">// &#123;a: &#x27;改变后的字符串&#x27;, b: &#123;c: 2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123;a: &#x27;原始字符串&#x27;, b: &#123;c: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>slice(数组)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> origin = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> copy = origin.<span class="title function_">slice</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy);</span><br></pre></td></tr></table></figure></li>
<li><p>concat</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> original = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> copy = original.<span class="title function_">concat</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><ol start="2">
<li>深拷贝相对于浅拷贝来说，不仅复制了对象本身及其包含的原始类型的值，还复制了所有引用类型的实际值。这意味着，如果你修改拷贝对象中的一个引用类型的值，原始对象中相应的值不会发生变化，因为它们指向了不同的内存地址。深拷贝不仅复制对象的第一层属性，还递归复制所有的嵌套对象。这意味着，无论对象有多少层嵌套，深拷贝都会创建所有层次的副本。因此，原始对象和拷贝对象之间不会相互影响。</li>
</ol>
<ul>
<li><p>JSON.parse(JSON.stringify(object))</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(original));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">NaN</span>))  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 JSON.stringify() 将对象序列化（转换为JSON字符串），然后使用 JSON.parse() 将字符串解析为新的对象。这种方法不能复制函数和循环引用的对象。</p>
</blockquote>
</li>
<li><p>递归拷贝</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> copy;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">    copy = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; obj.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        copy[i] = <span class="title function_">deepCopy</span>(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copy = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123; <span class="comment">// 检查是否是对象自身具有的属性，因为in会包含原型链上的属性，这里只拷贝自身的！</span></span><br><span class="line">                copy[key] = <span class="title function_">deepCopy</span>(obj[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用第三方库：如Lodash的 _.cloneDeep()</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = _.<span class="title function_">cloneDeep</span>(original);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/bolg/2023/02/16/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><h3 id="何为进程？"><a href="#何为进程？" class="headerlink" title="何为进程？"></a>何为进程？</h3><p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</p>
<img src="http://mdrs.yuanjin.tech/img/202208092057573.png" alt="image-20220809205743532" style="zoom:50%;" />

<p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p>
<h3 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a>何为线程？</h3><p>有了进程后，就可以运行程序的代码了。</p>
<p>运行代码的「人」称之为「线程」。</p>
<p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p>
<p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208092108499.png" alt="image-20220809210859457"></p>
<h3 id="浏览器有哪些进程和线程？"><a href="#浏览器有哪些进程和线程？" class="headerlink" title="浏览器有哪些进程和线程？"></a>浏览器有哪些进程和线程？</h3><p><strong>浏览器是一个多进程多线程的应用程序</strong></p>
<p>浏览器内部工作极其复杂。</p>
<p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208092131410.png" alt="image-20220809213152371"></p>
<blockquote>
<p>可以在浏览器的任务管理器中查看当前的所有进程</p>
</blockquote>
<p>其中，最主要的进程有：</p>
<ol>
<li><p>浏览器进程</p>
<p>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p>
</li>
<li><p>网络进程</p>
<p>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p>
</li>
<li><p><strong>渲染进程</strong>（本节课重点讲解的进程）</p>
<p>渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行 HTML、CSS、JS 代码。</p>
<p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p>
<blockquote>
<p>将来该默认模式可能会有所改变，有兴趣的同学可参见<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability">chrome官方说明文档</a></p>
</blockquote>
</li>
</ol>
<h2 id="渲染主线程是如何工作的？"><a href="#渲染主线程是如何工作的？" class="headerlink" title="渲染主线程是如何工作的？"></a>渲染主线程是如何工作的？</h2><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p>
<ul>
<li>解析 HTML</li>
<li>解析 CSS</li>
<li>计算样式</li>
<li>布局</li>
<li>处理图层</li>
<li>每秒把页面画 60 次</li>
<li>执行全局 JS 代码</li>
<li>执行事件处理函数</li>
<li>执行计时器的回调函数</li>
<li>……</li>
</ul>
<blockquote>
<p>思考题：为什么渲染进程不适用多个线程来处理这些事情？</p>
</blockquote>
<p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p>
<p>比如：</p>
<ul>
<li>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？</li>
<li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？</li>
<li>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？</li>
<li>……</li>
</ul>
<p>渲染主线程想出了一个绝妙的主意来处理这个问题：排队</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208092230847.png" alt="image-20220809223027806"></p>
<ol>
<li>在最开始的时候，渲染主线程会进入一个无限循环</li>
<li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</li>
<li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li>
</ol>
<p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p>
<p><strong>整个过程，被称之为事件循环（消息循环）</strong></p>
<h2 id="若干解释"><a href="#若干解释" class="headerlink" title="若干解释"></a>若干解释</h2><h3 id="何为异步？"><a href="#何为异步？" class="headerlink" title="何为异步？"></a>何为异步？</h3><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p>
<ul>
<li>计时完成后需要执行的任务 —— <code>setTimeout</code>、<code>setInterval</code></li>
<li>网络通信完成后需要执行的任务 – <code>XHR</code>、<code>Fetch</code></li>
<li>用户操作后需要执行的任务 – <code>addEventListener</code></li>
</ul>
<p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208101043348.png" alt="image-20220810104344296"></p>
<p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong></p>
<p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208101048899.png" alt="image-20220810104858857"></p>
<p>使用异步的方式，<strong>渲染主线程永不阻塞</strong></p>
<blockquote>
<p>面试题：如何理解 JS 的异步？</p>
<p>参考答案：</p>
<p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p>
<p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p>
<p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p>
<p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p>
<p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>
</blockquote>
<h3 id="JS为何会阻碍渲染？"><a href="#JS为何会阻碍渲染？" class="headerlink" title="JS为何会阻碍渲染？"></a>JS为何会阻碍渲染？</h3><p>先看代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Mr.Yuan is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> h1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 死循环指定的时间</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">duration</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - start &lt; duration) &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    h1.<span class="property">textContent</span> = <span class="string">&#x27;袁老师很帅！&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">delay</span>(<span class="number">3000</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击按钮后，会发生什么呢？</p>
<p>&lt;见具体演示&gt;</p>
<h3 id="任务有优先级吗？"><a href="#任务有优先级吗？" class="headerlink" title="任务有优先级吗？"></a>任务有优先级吗？</h3><p>任务没有优先级，在消息队列中先进先出</p>
<p>但<strong>消息队列是有优先级的</strong></p>
<p>根据 W3C 的最新解释:</p>
<ul>
<li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li>
<li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></li>
</ul>
<blockquote>
<p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p>
</blockquote>
<p>在目前 chrome 的实现中，至少包含了下面的队列：</p>
<ul>
<li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li>
<li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li>
<li>微队列：用户存放需要最快执行的任务，优先级「最高」</li>
</ul>
<blockquote>
<p>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即把一个函数添加到微队列</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(函数)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑</p>
</blockquote>
<blockquote>
<p>面试题：阐述一下 JS 的事件循环</p>
<p>参考答案：</p>
<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p>
<p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p>
<p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>
<p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p>
</blockquote>
<blockquote>
<p>面试题：JS 中的计时器能做到精确计时吗？为什么？</p>
<p>参考答案：</p>
<p>不行，因为：</p>
<ol>
<li>计算机硬件没有原子钟，无法做到精确计时</li>
<li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li>
<li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li>
</ol>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>你不知道的 CSS 之包含块</title>
    <url>/bolg/2024/02/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20CSS%20%E4%B9%8B%E5%8C%85%E5%90%AB%E5%9D%97/</url>
    <content><![CDATA[<p>一说到 <code>CSS</code> 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。</p>
<p>但是一说到 <code>CSS</code> 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142005.png" alt="image-20220814222004395" style="zoom: 20%;" />

<p>好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png" alt="image-20220813140434032" style="zoom:50%;" />

<p>包含块英语全称为 <code>containing block</code>，实际上平时你在书写 CSS 时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的：</p>
<p><em><a href="https://drafts.csswg.org/css2/#containing-block-details">https://drafts.csswg.org/css2/#containing-block-details</a></em></p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142459.png" alt="image-20220814222458695" style="zoom:50%;" />

<p>并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。</p>
<p>那么，这个包含块究竟说了什么内容呢？</p>
<p>说起来也简单，<strong>就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 <code> position</code> 被设置为 <code>absolute</code> 或 <code>fixed</code>），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</strong></p>
<p>来吧，少年，让我们从最简单的 case 开始看。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143153.png" alt="image-20220814223152726" style="zoom: 50%;" />

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143451.png" alt="image-20220814223451349" style="zoom: 33%;" />

<p>相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。</p>
<p>这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 <code>div.container</code> 的 <code>width</code> 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。</p>
<p>这个答案实际上是不准确的。正确的答案应该是，**<code>div.item</code> 的宽高是根据它的包含块来计算的**，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。</p>
<p>因此正如我前面所说，<strong>很多时候你都感受不到包含块的存在。</strong></p>
<p>包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</p>
<p>另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：</p>
<ul>
<li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。</li>
<li>如果 position 属性是 fixed，那么包含块由视口建立。</li>
<li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li>
</ul>
<p>前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。</p>
<p>公布正确答案：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-153548.png" alt="image-20220814233548188" style="zoom: 33%;" />

<p>怎么样？有没有和你所想象的对上？</p>
<p>其实原因也非常简单，根据上面的第三条规则，对于 <code>div.item2</code> 来讲，它的包含块应该是 <code>div.container</code>，而非 <code>div.item</code>。</p>
<p>如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。<br>实际上对于非根元素来讲，包含块还有一种可能，那就是如果 <code>position</code> 属性是 <code>absolute</code> 或 <code>fixed</code>，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：</p>
<ul>
<li><code>transform</code> 或 <code>perspective</code> 的值不是 <code>none</code></li>
<li><code>will-change</code> 的值是 <code>transform</code> 或 <code>perspective</code> </li>
<li><code>filter</code> 的值不是 <code>none</code> 或 <code>will-change</code> 的值是 <code>filter</code>(只在 <code>Firefox</code> 下生效). </li>
<li><code>contain</code> 的值是 <code>paint</code> (例如: contain: paint;)</li>
</ul>
<p>我们还是来看一个示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>); <span class="comment">/* 新增代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对于上面的代码只新增了一条声明，那就是<code> transform: rotate(0deg)</code>，此时的渲染效果却发生了改变，如下图所示：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154347.png" alt="image-20220814234347149" style="zoom:33%;" />

<p>可以看到，此时对于 <code>div.item2</code> 来讲，包含块就变成了<code> div.item</code>。</p>
<p>好了，到这里，关于包含块的知识就基本讲完了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png" alt="image-20220814234654914" style="zoom:33%;" />

<p>我们再把 CSS 规范中所举的例子来看一下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Illustration of containing blocks<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>This is text in the first paragraph...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span></span><br><span class="line">        This is text</span><br><span class="line">        <span class="tag">&lt;<span class="name">em</span> <span class="attr">id</span>=<span class="string">&quot;em1&quot;</span>&gt;</span></span><br><span class="line">          in the</span><br><span class="line">          <span class="tag">&lt;<span class="name">strong</span> <span class="attr">id</span>=<span class="string">&quot;strong1&quot;</span>&gt;</span>second<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">          paragraph.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面是一段简单的 <code>HTML</code> 代码，在没有添加任何 <code>CSS</code> 代码的情况下，你能说出各自的包含块么？</p>
<p>对应的结果如下：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>body</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>p2</td>
</tr>
<tr>
<td>strong1</td>
<td>p2</td>
</tr>
</tbody></table>
<p>首先 <code>HTML</code> 作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body 而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为 <code>html</code>，以此类推 <code>div1、p1、p2</code> 以及 <code>em1</code> 的包含块也都是它们的父元素。</p>
<p>不过 <code>strong1</code> 比较例外，它的包含块确实 <code>p2</code>，而非 <code>em1</code>。为什么会这样？建议你再把非根元素的第一条规则读一下：</p>
<ul>
<li>如果元素的 <code>positiion</code> 是 <code>relative</code> 或 <code>static</code> ，那么包含块由离它最近的<strong>块容器（block container）</strong>的内容区域（content area）的边缘建立。</li>
</ul>
<p>没错，因为 <code>em1</code> 不是块容器，而包含块是<strong>离它最近的块容器</strong>的内容区域，所以是 <code>p2</code>。</p>
<p>接下来添加如下的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#div1</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50px</span>; <span class="attribute">top</span>: <span class="number">50px</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码我们对 <code>div1</code> 进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。</p>
<p>答案如下：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>p2</td>
</tr>
<tr>
<td>strong1</td>
<td>p2</td>
</tr>
</tbody></table>
<p>可以看到，这里 <code>div1</code> 的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话：</p>
<ul>
<li>初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</li>
<li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li>
</ul>
<p>是不是一下子就理解了。没错，因为我们对 div1 进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的  <code>position</code> 的值不是 <code>static</code> 的祖先元素，不过显然 <code>body</code> 的定位方式为 <code>static</code>，因此 div1 的包含块最终就变成了初始包含块。</p>
<p>接下来我们继续修改我们的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#div1</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50px</span>; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#em1</span>  &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们对 <code>em1</code> 同样进行了 <code>absolute</code> 绝对定位，你想一想会有什么样的变化？</p>
<p>没错，聪明的你大概应该知道，<code>em1</code> 的包含块不再是 <code>p2</code>，而变成了 <code>div1</code>，而 <code>strong1</code> 的包含块也不再是 <code>p2</code> 了，而是变成了 <code>em1</code>。</p>
<p>如下表所示：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>div1（因为定位了，参阅非根元素包含块确定规则的第三条）</td>
</tr>
<tr>
<td>strong1</td>
<td>em1（因为 em1 变为了块容器，参阅非根元素包含块确定规则的第一条）</td>
</tr>
</tbody></table>
<p>好了，这就是 <code>CSS</code> 规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的 <code>CSS</code> 规范的人。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-013519.png" alt="image-20220815093518833" style="zoom:33%;" />

<p>另外，关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。</p>
<p>具体你可以移步到：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block</a></em></p>
<p>好了，这就是有关包含块的所有内容了，你学会了么？-）</p>
<hr>
<p>-<em>EOF</em>-</p>
]]></content>
  </entry>
  <entry>
    <title>如何区别进程和线程、协程的关系</title>
    <url>/bolg/2024/02/29/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%AB%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
</blockquote>
<ul>
<li>狭义定义：进程就是一段程序的执行过程例如启动的某个app。</li>
<li>广义定义：进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它是<code>操作系统动态执行的基本单元</code>，在传统的操作系统中,进程即是基本的分配单元，也是基本的执行单元。</li>
</ul>
<p><code>1.进程(process)最小的资源管理单元[操作系统] 2.应用程序的启动实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间</code></p>
<p>进程的生命周期基本由操作系统内核进行支配，即进程的创建、切换、销毁等操作都将使会陷入内核，进行系统调用。该操作消耗较大。当进行进程的销毁时，包含但不仅于内存地址空间、内核态堆栈和硬件上下文(CPU寄存器)的切换甚至在内存资源较少的情况下会将已存入内存的数据写入磁盘交换区，代价较大。因此，我们可以发现当系统运行的进程越多，系统越是卡顿。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>每个进程都有自己的地址空间，一般情况下，包含文本区域、数据区域、堆栈</li>
<li>进程是执行中的程序，程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称之为进程</li>
<li>进程本身不会运行，是线程的容器。线程不能单独执行，必须组成进程</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>对于操作系统来讲，一个任务就是一个进程，比如开一个浏览器就是启动一个浏览器进程。打开一款app就是打开一个进程。</li>
<li>有些进程还不止同时做一件事情。在一个进程内部，可以同时做多件事情，比如边看视频可以边发弹幕。</li>
</ul>
<h3 id="进程状态：（三状态）"><a href="#进程状态：（三状态）" class="headerlink" title="进程状态：（三状态）"></a>进程状态：（三状态）</h3><ul>
<li>就绪：获取CPU外的所有资源、只要处理器分配资源就可以马上执行</li>
<li>运行：获得处理器分配的资源，程序开始执行</li>
<li>阻塞：当程序条件不够的时候，需要等待提交满足的时候才能执行。</li>
</ul>
<h3 id="状态详解"><a href="#状态详解" class="headerlink" title="状态详解"></a>状态详解</h3><ul>
<li>创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，<code>完成资源分配</code>。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</li>
<li>就绪状态：进程已经准备好，<code>已分配到所需资源，只要分配到CPU就能够立即运行</code></li>
<li>执行状态：进程<code>处于就绪状态被调度后，进程进入执行状态</code></li>
<li>阻塞状态：正在执行的进程由于某些事件（I&#x2F;O请求，申请缓存区失败）而暂时无法运行，<code>进程受到阻塞</code>。在满足请求时进入就绪状态等待系统调用</li>
<li>终止状态：<code>进程结束，或出现错误，或被系统终止</code>，进入终止状态。无法再执行</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
</blockquote>
<p><code>1.线程(thread)最小的执行单元[操作系统] 2.一个进程包含多个线程(一主多从),拥有自己的栈空间</code></p>
<h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ul>
<li>一个进程中至少有一个线程，不然就没有存在的意义</li>
<li>在一个进程内部，要同时干多件事情，就需要同时运行多个子任务，我们把进程内的这些子任务叫做线程</li>
<li>多线程就是为了同步完成多项任务(在单个程序中同时运行多个线程完成不同的任务和工作)，是为了提高资源使用效率来提高系统的效率，而不是为了提高运行效率。</li>
<li>一个简单的比喻，多线程就像是给车保养的工人有洗车工有维修有美容的，而进程就是待被清洗维护美容店车</li>
<li>线程是程序执行流的最小单元。一个标准的线程由当前的线程ID、当前指令指针、寄存器和堆栈组成</li>
<li>同一个进程中的多个线程之间可以并发执行</li>
</ul>
<h3 id="线程状态："><a href="#线程状态：" class="headerlink" title="线程状态："></a>线程状态：</h3><ul>
<li>就绪：指线程具备运行的所有条件，逻辑上可以运行，在等待处理机</li>
<li>运行：指线程占用处理机正在运行</li>
<li>阻塞：线程在等待一个事件，逻辑上不可执行</li>
</ul>
<h3 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h3><ul>
<li><p>进程是操作系统资源分配的<code>基本单位</code>，而线程是任务调度和执行的基本单位</p>
<p>线程和进程的实现在操作系统之间有所不同，但在大多数情况下，线程是进程的一个组件。进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。在操作系统中能同时运行多个进程；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。</p>
</li>
<li><p>进程拥有独立的<code>内存空间</code>，线程则共享所在进程中的内存空间</p>
<p>进程是系统中独立存在的实体，它可以拥有自己独立的资源，系统在运行的时候会为每个进程分配不同的内存空间，所以每一个进程都拥有自己私有的内存空间。在没有经过进程本身允许的情况下，一个用户的进程不可以直接访问其它进程的内存空间。而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），一个进程中的多个线程之间只能共享进程的资源。而不同的进程不共享这些资源。</p>
</li>
<li><p>进程之间切换开销较大，而线程间切换<code>开销</code>较小</p>
<p>每个进程都有独立的数据空间（程序上下文），进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程的切换的消耗随略小于进程，较少进行内存和磁盘的交换，但是仍然会有堆栈的映射和切换。</p>
</li>
<li><p>程序是一个静态<code>指令的集合</code>，而进程是一个正在系统中活动的指令集合</p>
<p>进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态，这写概念在程序中是不具备的。</p>
</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的<strong>轻量级线程</strong>，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。</p>
<p><code>1.协程(Coroutines)特殊的函数[程序控制] 2.一个线程可以拥有多个协程 3.可以暂停执行（暂停的表达式称为暂停点) 4.可以从挂起点恢复（保留其原始参数和局部变量） 5.事件循环是异步编程的底层基石</code></p>
<p>从名字可以看出，协程的粒度比线程更小，并且是用户管理和控制的，多个协程可以运行在一个线程上面。那么协程出现的背景又是什么呢，先来看一下目前线程中影响性能的特性：</p>
<ul>
<li>使用锁机制</li>
<li>线程间的上下文切换</li>
<li>线程运行和阻塞状态的切换</li>
</ul>
<p>以上任意一点都是很消耗cpu性能的。相对来说协程是由程序自身控制，没有线程切换的开销，且不需要锁机制，因为在同一个线程中运行，不存在同时写变量冲突，在协程中操作共享资源不加锁，只需要判断状态就行了，所以执行效率比线程高的多。</p>
<h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p>
<ul>
<li><p>对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p>
</li>
<li><p>对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）</p>
</li>
</ul>
<h3 id="协程的优点："><a href="#协程的优点：" class="headerlink" title="协程的优点："></a>协程的优点：</h3><ol>
<li>无需线程上下文切换的开销，goroutine(协程) 切换调度开销方面远比线程小。</li>
<li>无需原子操作锁定及同步的开销</li>
<li>方便切换控制流，简化编程模型</li>
<li>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。goroutine：2KB（官方），线程：8MB（参考网络）</li>
</ol>
<p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p>
<h3 id="协程的缺点："><a href="#协程的缺点：" class="headerlink" title="协程的缺点："></a>协程的缺点：</h3><ol>
<li>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li>
<li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</li>
</ol>
<p><strong>CPU密集型代码(各种循环处理、计算等等)：使用多进程。IO密集型代码(文件处理、网络爬虫等)：使用多线程</strong></p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><strong>并发与并行</strong></h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。</p>
<p>当有多个线程时，如果系统只有一个CPU，那么CPU不可能真正同时进行多个线程，CPU的运行时间会被划分成若干个时间段，每个时间段分配给各个线程去执行，一个时间段里某个线程运行时，其他线程处于挂起状态，这就是并发。并发解决了程序排队等待的问题，如果一个程序发生阻塞，其他程序仍然可以正常执行。</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。</p>
<h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ol>
<li>并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。</li>
<li>在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。</li>
</ol>
<p>知乎上高赞例子：</p>
<ul>
<li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li>
<li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li>
<li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li>
</ul>
<p>并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是 <strong>『同时』</strong>。</p>
<h2 id="JavaScript中的协程"><a href="#JavaScript中的协程" class="headerlink" title="JavaScript中的协程"></a>JavaScript中的协程</h2><h3 id="JavaScript-协程的发展"><a href="#JavaScript-协程的发展" class="headerlink" title="JavaScript 协程的发展"></a>JavaScript 协程的发展</h3><ul>
<li>同步代码</li>
<li>异步JavaScript: callback hell（回调地狱）</li>
<li>ES6引入 Promise&#x2F;a+, 生成器Generators(语法 _<em>function</em> foo(){}_*  可以赋予函数执行暂停&#x2F;保存上下文&#x2F;恢复执行状态的功能), 新关键词yield使生成器函数暂停.</li>
<li>ES7引入 async函数&#x2F;await语法糖,async可以声明一个异步函数(将Generator函数和自动执行器，包装在一个函数里)，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果,</li>
</ul>
<p>Promise中也利用了回调函数。在then和catch方法中都传入了一个回调函数，分别在Promise被满足和被拒绝时执行, 这样就就能让它能够被链接起来完成一系列任务。总之就是把层层嵌套的 callback 变成 .then().then()…，从而使代码编写和阅读更直观</p>
<p>生成器Generator的底层实现机制是协程Coroutine。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo start&quot;</span>)     a = <span class="keyword">yield</span> <span class="number">1</span>;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo a&quot;</span>, a)     <span class="keyword">yield</span> <span class="number">2</span>;     <span class="keyword">yield</span> <span class="number">3</span>;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo end&quot;</span>) &#125; <span class="keyword">const</span> gen = <span class="title function_">foo</span>(); <span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1 // gen.send(&quot;a&quot;) // http://www.voidcn.com/article/p-syzbwqht-bvv.html SpiderMonkey引擎支持 send 语法 console.log(gen.next().value); // 2 console.log(gen.next().value); // 3 console.log(foo().next().value); // 1 console.log(foo().next().value); // 1 /* foo start 1 foo a undefined 2 3 foo start 1 foo start 1 */</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-协程成熟体"><a href="#JavaScript-协程成熟体" class="headerlink" title="JavaScript 协程成熟体"></a>JavaScript 协程成熟体</h3><h4 id="Promise继续使用"><a href="#Promise继续使用" class="headerlink" title="Promise继续使用"></a>Promise继续使用</h4><p>Promise 本质是一个状态机，用于表示一个异步操作的最终完成 (或失败), 及其结果值。它有三个状态：</p>
<ul>
<li>pending: 初始状态，既不是成功，也不是失败状态。</li>
<li>fulfilled: 意味着操作成功完成。</li>
<li>rejected: 意味着操作失败。</li>
</ul>
<p>最终 Promise 会有两种状态，一种成功，一种失败，当 pending 变化的时候，Promise 对象会根据最终的状态调用不同的处理函数。</p>
<h4 id="async、await语法糖"><a href="#async、await语法糖" class="headerlink" title="async、await语法糖"></a>async、await语法糖</h4><p>async、await 是对 Generator 和 Promise 组合的封装, 使原先的异步代码在形式上更接近同步代码的写法,并且对错误处理&#x2F;条件分支&#x2F;异常堆栈&#x2F;调试等操作更友好。Async、Await 实现了 Generator 的自动迭代，正因为 Async、Await 是对 Generator 和 Promise 组合的封装，所以 Async 和 Await 基本上就只能用来实现异步和并发了，而不具有协程的其他作用。</p>
<h3 id="JavaScript-异步执行的运行机制"><a href="#JavaScript-异步执行的运行机制" class="headerlink" title="JavaScript 异步执行的运行机制"></a>JavaScript 异步执行的运行机制</h3><ol>
<li>所有任务都在主线程上执行，形成一个执行栈。\</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。\</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。</li>
</ol>
<p>遇到同步任务直接执行,遇到异步任务分类为宏任务(macro-task)和微任务(micro-task)。<br>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sleep = <span class="keyword">function</span> (<span class="params">time</span>) &#123;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sleep start&quot;</span>)     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;         <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;             <span class="title function_">resolve</span>();         &#125;, time);     &#125;); &#125;; <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">exec</span>(<span class="params"></span>) &#123;     <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">2000</span>);     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sleep end&quot;</span>) &#125; <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params"></span>) &#123;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>())     c1 = <span class="title function_">exec</span>()     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------1&quot;</span>)     c2 = <span class="title function_">exec</span>()     <span class="variable language_">console</span>.<span class="title function_">log</span>(c1, c2)     <span class="keyword">await</span> c1;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------2&quot;</span>)     <span class="keyword">await</span> c2;     <span class="variable language_">console</span>.<span class="title function_">log</span>(c1, c2)     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>()) &#125; <span class="title function_">go</span>();</span><br></pre></td></tr></table></figure>

<h3 id="event-loop将任务划分："><a href="#event-loop将任务划分：" class="headerlink" title="event loop将任务划分："></a>event loop将任务划分：</h3><ul>
<li>主线程循环从”任务队列”中读取事件</li>
<li>宏队列（macro task）js同步执行的代码块，setTimeout、setInterval、XMLHttprequest、setImmediate、I&#x2F;O、UI rendering等, 本质是参与了事件循环的任务.</li>
<li>微队列（micro task）Promise、process.nextTick（node环境）、Object.observe, MutationObserver等,本质是直接在 Javascript 引擎中的执行的没有参与事件循环的任务.</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h2><ol>
<li>线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。</li>
<li>对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。</li>
<li>所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</li>
</ol>
<p>总结：进程、线程和协程的设计，都是为了并发任务能够更好的利用CPU资源，他们最大的区别即在于对CPU的使用上(任务调度)：如前文所述，进程和线程的任务调度由内核控制，是抢占式的；而协程的任务调度在用户态完成，需要在代码里显式的把CPU交给其他协程，是协作式的。</p>
<p>由于我们可以在用户态调度协程任务，所以，我们可以把一组互相依赖的任务设计成协程。这样，当一个协程任务完成之后，可以手动进行任务调度，把自己挂起(yield)，切换到另外一个协程执行。这样，由于我们可以控制程序主动让出资源，很多情况下将不需要对资源加锁。</p>
]]></content>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/bolg/2024/02/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h1><p>当浏览器的网络线程收到 <code>HTML</code> 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列（如图1）。</p>
<p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p>
<p><img src="/bolg/images/browserRender/img_01.png" alt="渲染流程"></p>
<p>整个渲染流程分为多个阶段，分别是： <code>HTML</code> 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p>
<p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p>
<p>这样，整个渲染流程就形成了一套组织严密的生产流水线。<br><img src="/bolg/images/browserRender/img_02.png" alt="渲染主线程"></p>
<h2 id="解析-HTML"><a href="#解析-HTML" class="headerlink" title="解析 HTML"></a>解析 <code>HTML</code></h2><p>解析过程中遇到 <code>CSS</code> 解析 <code> CSS</code>，遇到 <code>JS</code> 执行 <code>JS</code>。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 <code>HTML</code> 中的外部 <code>CSS</code> 文件和 外部的 <code>JS</code> 文件。</p>
<p>如果主线程解析到<code>link</code>位置，此时外部的 <code>CSS</code> 文件还没有下载解析好，主线程不会等待，继续解析后续的 <code>HTML</code>。这是因为下载和解析 <code>CSS</code> 的工作是在预解析线程中进行的。这就是 <code>CSS</code> 不会阻塞<code> HTML</code> 解析的根本原因。</p>
<p>如果主线程解析到<code>script</code>位置，会停止解析<code> HTML</code>，转而等待 <code>JS</code> 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 <code>JS</code> 代码的执行过程可能会修改当前的 <code>DOM</code> 树，所以 <code>DOM</code> 树的生成必须暂停。这就是 <code>JS</code> 会阻塞 <code>HTML</code> 解析的根本原因。</p>
<p>第一步完成后，会得到 <code>DOM</code> 树和 <code>CSSOM</code> 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 <code>CSSOM</code> 树中。</p>
<p><img src="/bolg/images/browserRender/img_04.png" alt="解析 HTML"></p>
<h2 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h2><p>主线程会遍历得到的 <code>DOM</code> 树，依次为树中的每个节点计算出它最终的样式，称之为 <code>Computed Style</code>。</p>
<p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p>
<p>这一步完成后，会得到一棵带有样式的 <code>DOM</code> 树。<br><img src="/bolg/images/browserRender/img_08.png" alt="样式计算"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局阶段会依次遍历 <code>DOM</code> 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p>
<p>大部分时候，<code>DOM</code> 树和布局树并非一一对应。</p>
<p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p>
<p><img src="/bolg/images/browserRender/img_09.png" alt="布局"><br><img src="/bolg/images/browserRender/img_10.png" alt="移除隐藏元素"><br><img src="/bolg/images/browserRender/img_11.png" alt="生成匿名块"></p>
<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p>
<p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p>
<p>滚动条、堆叠上下文、<code>transform</code>、<code>opacity</code> 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。<br><img src="/bolg/images/browserRender/img_12.png" alt="分层"></p>
<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p>
<p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p>
<p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p>
<p>它会从线程池中拿取多个线程来完成分块工作。<br><img src="/bolg/images/browserRender/img_13.png" alt="绘制"></p>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>合成线程会将块信息交给 <code>GPU</code> 进程，以极高的速度完成光栅化。</p>
<p><code>GPU</code> 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p>
<p>光栅化的结果，就是一块一块的位图<br><img src="/bolg/images/browserRender/img_15.png" alt="光栅化"><br><img src="/bolg/images/browserRender/img_16.png" alt="光栅化"><br><img src="/bolg/images/browserRender/img_18.png" alt="光栅化"><br><img src="/bolg/images/browserRender/img_17.png" alt="光栅化"></p>
<h2 id="画"><a href="#画" class="headerlink" title="画"></a>画</h2><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p>
<p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p>
<p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p>
<p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。<br><img src="/bolg/images/browserRender/img_19.png" alt="画"></p>
<h1 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h1><p>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 <code>layout</code>。</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 <code>JS</code> 代码全部完成后再进行统一计算。所以，改动属性造成的 <code>reflow</code> 是异步完成的。</p>
<p>也同样因为如此，当 <code>JS</code> 获取布局属性时，就可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定获取属性立即 <code>reflow</code>。<br><img src="/bolg/images/browserRender/img_23.png" alt="reflow"></p>
<h1 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h1><p><code>repaint</code> 的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，会引发 <code>repaint</code>。</p>
<p>由于元素的布局信息也属于可见样式，所以 <code>reflow</code> 一定会引起 <code>repaint</code>。<br><img src="/bolg/images/browserRender/img_22.png" alt="repaint"></p>
<h1 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h1><p>因为 <code>transform</code> 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「<code>draw</code>」阶段</p>
<p>由于 <code>draw</code> 阶段在合成线程中，所以 <code>transform</code> 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 <code>transform</code> 的变化。<br><img src="/bolg/images/browserRender/img_21.png" alt="transform"></p>
]]></content>
  </entry>
  <entry>
    <title>深入理解vite原理</title>
    <url>/bolg/2024/03/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3vite%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Vite介绍"><a href="#Vite介绍" class="headerlink" title="Vite介绍"></a>Vite介绍</h1><h2 id="Vite是什么？"><a href="#Vite是什么？" class="headerlink" title="Vite是什么？"></a>Vite是什么？</h2><p><code>Vite</code>是新一代的前端构建工具，在尤雨溪开发<code>Vue3.0</code>的时候诞生。类似于<code>Webpack</code>+ <code>Webpack-dev-server</code>。其主要利用浏览器<code>ESM</code>特性导入组织代码，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。生产中利用<code>Rollup</code>作为打包工具，号称下一代的前端构建工具。</p>
<p><code>Vite</code>有如下特点：</p>
<ul>
<li><p>快速的冷启动: <code>No Bundle</code> + <code>esbuild</code> 预构建</p>
</li>
<li><p>即时的模块热更新: 基于<code>ESM</code>的<code>HMR</code>，同时利用浏览器缓存策略提升速度</p>
</li>
<li><p>真正的按需加载: 利用浏览器<code>ESM</code>支持，实现真正的按需加载</p>
</li>
</ul>
<h2 id="Vite和传统打包方式的对比"><a href="#Vite和传统打包方式的对比" class="headerlink" title="Vite和传统打包方式的对比"></a>Vite和传统打包方式的对比</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="center">开发环境</th>
<th align="right">生产构建</th>
<th align="right">Dev启动速度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">vite</td>
<td align="center">NO Bundle (CJS-ESM)</td>
<td align="right">Rollup&#x2F;webpack</td>
<td align="right">快</td>
</tr>
<tr>
<td align="left">webpack</td>
<td align="center">Bundle (CJS&#x2F;UMD&#x2F;ESM)</td>
<td align="right">webpack</td>
<td align="right">慢（项目规模递增）</td>
</tr>
</tbody></table>
<h3 id="VS-Webapck"><a href="#VS-Webapck" class="headerlink" title="VS Webapck"></a>VS Webapck</h3><p><code>Webpack</code>是近年来使用量最大，同时社区最完善的前端打包构建工具，新出的<code>5.x</code>版本对构建细节进行了优化，在部分场景下打包速度提升明显。<code>Webpack</code>在启动时，会先构建项目模块的依赖图，如果在项目中的某个地方改动了代码，<code>Webpack</code>则会对相关的依赖重新打包，随着项目的增大，其打包速度也会下降。</p>
<p><code>Vite</code>相比于<code>Webpack</code>而言，没有打包的过程，而是直接启动了一个开发服务器devServer。<code>Vite</code>劫持浏览器的<code>HTTP</code>请求，在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再返回给浏览器(整个过程没有对文件进行打包编译)。所以编译速度很快。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h2><p>在了解<code>Vite</code>之前，需要先了解下<code>ESM</code></p>
<p><code>ESM</code>是<code>JavaScript</code>提出的官方标准化模块系统，不同于之前的<code>CJS</code>，<code>AMD</code>，<code>CMD</code>等等，<code>ESM</code>提供了更原生以及更动态的模块加载方案，最重要的就是它是浏览器原生支持的，也就是说我们可以直接在浏览器中去执行<code>import</code>，动态引入我们需要的模块，而不是把所有模块打包在一起。</p>
<p>目前<code>ESM</code>模块化已经支持92%以上的浏览器，而且且作为 <code>ECMA</code> 标准，未来会有更多浏览器支持<code>ECMA</code>规范</p>
<p><img src="/bolg/images/vite/img_01.png" alt="ESM兼容性"></p>
<p>当我们在使用模块开发时，其实就是在构建一张模块依赖关系图，当模块加载时，就会从入口文件开始，最终生成完整的模块实例图。</p>
<p><code>ESM</code>的执行可以分为三个步骤：</p>
<ul>
<li><p>构建: 确定从哪里下载该模块文件、下载并将所有的文件解析为模块记录</p>
</li>
<li><p>实例化: 将模块记录转换为一个模块实例，为所有的模块分配内存空间，依照导出、导入语句把模块指向对应的内存地址。</p>
</li>
<li><p>运行：运行代码，将内存空间填充</p>
</li>
</ul>
<p>从上面实例化的过程可以看出，<code>ESM</code>使用实时绑定的模式，导出和导入的模块都指向相同的内存地址，也就是值引用。而<code>CJS</code>采用的是值拷贝，即所有导出值都是拷贝值。</p>
<h2 id="Esbuild"><a href="#Esbuild" class="headerlink" title="Esbuild"></a>Esbuild</h2><p><code>Vite</code>底层使用<code>Esbuild</code>实现对<code>.ts</code>、<code>jsx</code>、<code>.js</code>代码文件的转化，所以先看下什么是<code>es-build</code>。</p>
<p><code>Esbuild</code>是一个<code>JavaScript`` Bundler</code> 打包和压缩工具，它提供了与<code>Webpack</code>、<code>Rollup</code>等工具相似的资源打包能力。可以将<code>JavaScript</code> 和<code>TypeScript</code>代码打包分发在网页上运行。但其打包速度却是其他工具的10～100倍。</p>
<p>目前他支持以下的功能：</p>
<ul>
<li><p>加载器</p>
</li>
<li><p>压缩</p>
</li>
<li><p>打包</p>
</li>
<li><p><code>Tree shaking</code></p>
</li>
<li><p><code>Source map</code>生成</p>
</li>
</ul>
<p><code>esbuild</code>总共提供了四个函数：<code>transform</code>、<code>build</code>、<code>buildSync</code>、<code>Service</code>。有兴趣的可以移步<a href="https://esbuild.github.io/api/">官方文档</a>了解。</p>
<h2 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h2><p>在生产环境下，<code>Vite</code>使用<code>Rollup</code>来进行打包</p>
<p><code>Rollup</code>是基于<code>ESM</code>的<code>JavaScript</code>打包工具。相比于其他打包工具如<code>Webpack</code>，他总是能打出更小、更快的包。因为 <code>Rollup</code> 基于 <code>ESM</code> 模块，比 <code>Webpack</code> 和 <code>Browserify</code> 使用的 <code>CommonJS</code>模块机制更高效。<code>Rollup</code>的亮点在于同一个地方，一次性加载。能针对源码进行 <code>Tree Shaking</code>(去除那些已被定义但没被使用的代码)，以及 <code>Scope Hoisting</code> 以减小输出文件大小提升运行性能。</p>
<p><code>Rollup</code>分为<code>build</code>（构建）阶段和<code>output generate</code>（输出生成）阶段。主要过程如下：</p>
<ul>
<li><p>获取入口文件的内容，包装成<code>module</code>，生成抽象语法树</p>
</li>
<li><p>对入口文件抽象语法树进行依赖解析</p>
</li>
<li><p>生成最终代码</p>
</li>
<li><p>写入目标文件</p>
</li>
</ul>
<p>如果你的项目（特别是类库）只有<code>JavaScript</code>，而没有其他的静态资源文件，使用<code>Webpack</code>就有点大才小用了。因为<code>Webpack</code> 打包的文件的体积略大，运行略慢，可读性略低。这时候<code>Rollup</code>也不失为一个好选择。</p>
<p>这里想对Rollp进行更深入的学习可以看看<a href="https://rollupjs.org/guide/en/">官网的介绍</a>。</p>
<h1 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h1><p>详细阐述下：</p>
<ol>
<li>当声明一个 <code>script</code>标签类型为 <code>module</code> 时</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当浏览器解析资源时，会往当前域名发起一个<code>GET</code>请求<code>main.js</code>文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>请求到了<code>main.js</code>文件，会检测到内部含有<code>import</code>引入的包，又会<code>import</code> 引用发起<code>HTTP</code>请求获取模块的内容文件，如<code>App.vue</code>、<code>vue</code>文件</li>
</ol>
<p><code>Vite</code>其核心原理是利用浏览器现在已经支持<code>ES6</code>的<code>import</code>,碰见<code>import</code>就会发送一个<code>HTTP</code>请求去加载文件，<code>Vite</code>启动一个 <code>koa</code> 服务器拦截这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再以<code>ESM</code>格式返回给浏览器。<code>Vite</code>整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的<code>webpack</code>开发编译速度快出许多！</p>
<h2 id="基于ESM的Dev-server"><a href="#基于ESM的Dev-server" class="headerlink" title="基于ESM的Dev server"></a>基于ESM的Dev server</h2><p>在<code>Vite</code>出来之前，传统的打包工具如<code>Webpack</code>是先解析依赖、打包构建再启动开发服务器，<code>Dev Server</code> 必须等待所有模块构建完成，当我们修改了 <code>bundle</code>模块中的一个子模块， 整个 <code>bundle</code> 文件都会重新打包然后输出。项目应用越大，启动时间越长。</p>
<p><img src="/bolg/images/vite/img_02.png" alt="webpack启动流程"></p>
<p>而<code>Vite</code>利用浏览器对<code>ESM</code>的支持，当 <code>import</code> 模块时，浏览器就会下载被导入的模块。先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件,本质上实现了动态加载。灰色部分是暂时没有用到的路由，所有这部分不会参与构建过程。随着项目里的应用越来越多，增加<code>route</code>，也不会影响其构建速度。</p>
<p><img src="/bolg/images/vite/img_03.png" alt="vite启动流程"></p>
<h2 id="基于ESM-的-HMR-热更新"><a href="#基于ESM-的-HMR-热更新" class="headerlink" title="基于ESM 的 HMR 热更新"></a>基于ESM 的 HMR 热更新</h2><p>目前所有的打包工具实现热更新的思路都大同小异：主要是通过<code>WebSocket</code>创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作的更新。</p>
<h3 id="VS-Webpack"><a href="#VS-Webpack" class="headerlink" title="VS Webpack"></a>VS Webpack</h3><ol>
<li><p><code>Webpack</code>: 重新编译，请求变更后模块的代码，客户端重新加载</p>
</li>
<li><p><code>Vite</code>: 请求变更的模块，再重新加载</p>
</li>
</ol>
<p><code>Vite</code> 通过 <code>chokidar</code> 来监听文件系统的变更，只用对发生变更的模块重新加载， 只需要精确的使相关模块与其临近的 <code>HMR</code>边界连接失效即可，这样<code>HMR</code> 更新速度就不会因为应用体积的增加而变慢而 <code>Webpack</code> 还要经历一次打包构建。所以 <code>HMR</code> 场景下，<code>Vite</code> 表现也要好于 <code>Webpack</code>。</p>
<h3 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h3><p><code>Vite</code>整个热更新过程可以分成四步</p>
<ol>
<li><p>创建一个<code>websocket</code>服务端和<code>client</code>文件，启动服务</p>
</li>
<li><p>通过<code>chokidar</code>监听文件变更</p>
</li>
<li><p>当代码变更后，服务端进行判断并推送到客户端</p>
</li>
<li><p>客户端根据推送的信息执行不同操作的更新</p>
</li>
</ol>
<p>整体流程图：</p>
<p><img src="/bolg/images/vite/img_04.png" alt="vite启动流程图"></p>
<ol>
<li>启动热更新：createWebSocketServer</li>
</ol>
<p>在 <code>Vite`` dev server</code> 启动之前，<code>Vite</code> 会为 <code>HMR</code> 做一些准备工作：比如创建<code>websocket</code>服务，利用<code>chokidar</code>创建一个监听对象 <code>watcher</code> 用于对文件修改进行监听等等，具体核心代码：</p>
<blockquote>
<p>源码位置：packages&#x2F;vite&#x2F;src&#x2F;node&#x2F;server&#x2F;index.ts</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">createServer</span>(<span class="params">inlineConfig: InlineConfig = &#123;&#125; </span>): <span class="title class_">Promise</span>&lt;<span class="title class_">ViteDevServer</span>&gt; &#123;  <span class="keyword">const</span> ws = <span class="title function_">createWebSocketServer</span>(httpServer, config, httpsOptions)  </span><br><span class="line"><span class="keyword">const</span> &#123; ignored = [], ...watchOptions &#125; = serverConfig.<span class="property">watch</span> || &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> watcher = chokidar.<span class="title function_">watch</span>(path.<span class="title function_">resolve</span>(root), &#123;     </span><br><span class="line"><span class="attr">ignored</span>: [<span class="string">&#x27;**/node_modules/**&#x27;</span>,<span class="string">&#x27;**/.git/**&#x27;</span>,...(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(ignored) ? ignored : [ignored])],    <span class="attr">ignoreInitial</span>: <span class="literal">true</span>,     </span><br><span class="line"><span class="attr">ignorePermissionErrors</span>: <span class="literal">true</span>,     </span><br><span class="line"><span class="attr">disableGlobbing</span>: <span class="literal">true</span>,    </span><br><span class="line">...watchOptions   </span><br><span class="line">&#125;) <span class="keyword">as</span> <span class="title class_">FSWatcher</span>   </span><br><span class="line">...</span><br><span class="line"><span class="comment">// 监听文件的修改</span></span><br><span class="line">watcher.<span class="title function_">on</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">async</span> (file) =&gt; &#123;   &#125;)   </span><br><span class="line"><span class="comment">// 监听文件的新增</span></span><br><span class="line">watcher.<span class="title function_">on</span>(<span class="string">&#x27;add&#x27;</span>, <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 监听文件失效</span></span><br><span class="line">watcher.<span class="title function_">on</span>(<span class="string">&#x27;unlink&#x27;</span>, <span class="function">(<span class="params">file</span>) =&gt;</span> &#123; &#125;)   </span><br><span class="line">...  </span><br><span class="line"><span class="keyword">return</span> server </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createWebSocketServer</code>这个方法主是创建<code>WebSocket</code>服务并对错误进行一些处理，最后返回封装好的<code>on</code>、<code>off</code>、 <code>send</code> 和 <code>close</code> 方法，用于后续服务端推送消息和关闭服务。</p>
<blockquote>
<p>源码位置：packages&#x2F;vite&#x2F;src&#x2F;node&#x2F;server&#x2F;ws.ts</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createWebSocketServer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  server: Server | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  config: ResolvedConfig,</span></span><br><span class="line"><span class="params">  httpsOptions?: HttpsServerOptions</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">wss</span>: <span class="title class_">WebSocket</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">httpsServer</span>: <span class="title class_">Server</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 热更新配置</span></span><br><span class="line">  <span class="keyword">const</span> hmr = <span class="title function_">isObject</span>(config.<span class="property">server</span>.<span class="property">hmr</span>) &amp;&amp; config.<span class="property">server</span>.<span class="property">hmr</span></span><br><span class="line">  <span class="keyword">const</span> wsServer = (hmr &amp;&amp; hmr.<span class="property">server</span>) || server</span><br><span class="line">  <span class="comment">// 普通模式</span></span><br><span class="line">  <span class="keyword">if</span> (wsServer) &#123;</span><br><span class="line">    wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(&#123; <span class="attr">noServer</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    wsServer.<span class="title function_">on</span>(<span class="string">&#x27;upgrade&#x27;</span>, <span class="function">(<span class="params">req, socket, head</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 监听通过vite客户端发送的websocket消息，通过HMR_HEADER区分</span></span><br><span class="line">      <span class="keyword">if</span> (req.<span class="property">headers</span>[<span class="string">&#x27;sec-websocket-protocol&#x27;</span>] === <span class="variable constant_">HMR_HEADER</span>) &#123;</span><br><span class="line">        wss.<span class="title function_">handleUpgrade</span>(req, socket <span class="keyword">as</span> <span class="title class_">Socket</span>, head, <span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">          wss.<span class="title function_">emit</span>(<span class="string">&#x27;connection&#x27;</span>, ws, req)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 中间件模式</span></span><br><span class="line">    <span class="comment">// vite dev server in middleware mode</span></span><br><span class="line">    wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(websocketServerOptions)</span><br><span class="line">  &#125;</span><br><span class="line">  wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 错误处理</span></span><br><span class="line">  wss.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">e: <span class="built_in">Error</span> &amp; &#123; code: <span class="built_in">string</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 返回</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">on</span>: wss.<span class="property">on</span>.<span class="title function_">bind</span>(wss),</span><br><span class="line">    <span class="attr">off</span>: wss.<span class="property">off</span>.<span class="title function_">bind</span>(wss),</span><br><span class="line">    <span class="title function_">send</span>(<span class="params">payload: HMRPayload</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">close</span>(<span class="params"></span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>执行热更新：moduleGraph+handleHMRUpdate模块</li>
</ol>
<p>接收到文件改动执行的回调，这里主要两个操作：<code>moduleGraph.onFileChange</code>修改文件的缓存和<code>handleHMRUpdate</code>执行热更新</p>
<blockquote>
<p>源码位置：packages&#x2F;vite&#x2F;src&#x2F;node&#x2F;server&#x2F;index.ts</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watcher.<span class="title function_">on</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">async</span> (file) =&gt; &#123;</span><br><span class="line">   file = <span class="title function_">normalizePath</span>(file)</span><br><span class="line">   <span class="keyword">if</span> (file.<span class="title function_">endsWith</span>(<span class="string">&#x27;/package.json&#x27;</span>)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">invalidatePackageData</span>(packageCache, file)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// invalidate module graph cache on file change</span></span><br><span class="line">   moduleGraph.<span class="title function_">onFileChange</span>(file)</span><br><span class="line">   <span class="keyword">if</span> (serverConfig.<span class="property">hmr</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">await</span> <span class="title function_">handleHMRUpdate</span>(file, server)</span><br><span class="line">     &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">       ws.<span class="title function_">send</span>(&#123;</span><br><span class="line">         <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">         <span class="attr">err</span>: <span class="title function_">prepareError</span>(err)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>moduleGraph</li>
</ul>
<p><code>moduleGraph</code> 是<code>Vite</code>定义的用来记录整个应用的模块依赖图的类，除此之外还有<code>moduleNode</code>。</p>
<blockquote>
<p>源码位置：packages&#x2F;vite&#x2F;src&#x2F;node&#x2F;server&#x2F;moduleGraph.ts</p>
</blockquote>
<p><strong>图片</strong></p>
<p><code>moduleGraph</code>是由一系列 <code>map</code> 组成，而这些<code>map</code>分别是<code>url</code>、<code>id</code>、<code>file</code>等与<code>ModuleNode</code>的映射，而<code>ModuleNode</code> 是 <code>Vite</code>中定义的最小模块单位。通过这两个类可以构建下面的模块依赖图：</p>
<p><strong>图片</strong></p>
<p>可以看看<code>moduleGraph.onFileChange</code>这个函数：主要是用来清空被修改文件对应的<code>ModuleNode</code>对象的 <code>transformResult</code> 属性，使之前的模块已有的转换缓存失效。这块也就是<code>Vite</code>在热更新里的缓存机制。可以看看官网的<a href="https://cn.vitejs.dev/guide/dep-pre-bundling.html#customizing-the-behavior">介绍</a>。</p>
<blockquote>
<p>源码位置：packages&#x2F;vite&#x2F;src&#x2F;node&#x2F;server&#x2F;moduleGraph.ts</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onFileChange</span>(<span class="attr">file</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mods = <span class="variable language_">this</span>.<span class="title function_">getModulesByFile</span>(file)</span><br><span class="line">    <span class="keyword">if</span> (mods) &#123;</span><br><span class="line">      <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">ModuleNode</span>&gt;()</span><br><span class="line">      mods.<span class="title function_">forEach</span>(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">invalidateModule</span>(mod, seen)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">invalidateModule</span>(<span class="attr">mod</span>: <span class="title class_">ModuleNode</span>, <span class="attr">seen</span>: <span class="title class_">Set</span>&lt;<span class="title class_">ModuleNode</span>&gt; = <span class="keyword">new</span> <span class="title class_">Set</span>()): <span class="built_in">void</span> &#123;</span><br><span class="line">    mod.<span class="property">info</span> = <span class="literal">undefined</span></span><br><span class="line">    mod.<span class="property">transformResult</span> = <span class="literal">null</span></span><br><span class="line">    mod.<span class="property">ssrTransformResult</span> = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">invalidateSSRModule</span>(mod, seen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>handleHMRUpdate</li>
</ul>
<p><code>handleHMRUpdate</code> 模块主要是监听文件的更改，进行处理和判断通过<code>WebSocket</code>给客户端发送消息通知客户端去请求新的模块代码。</p>
<blockquote>
<p>源码位置：packages&#x2F;vite&#x2F;packages&#x2F;vite&#x2F;src&#x2F;node&#x2F;server&#x2F;hmr.ts</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 部分核心代码</span></span><br><span class="line"><span class="keyword">if</span> (file === config.<span class="property">configFile</span> || file.<span class="title function_">endsWith</span>(<span class="string">&#x27;.env&#x27;</span>)) &#123;</span><br><span class="line">  <span class="comment">// auto restart server 配置&amp;环境文件修改则自动重启服务</span></span><br><span class="line">  <span class="title function_">debugHmr</span>(<span class="string">`[config change] <span class="subst">$&#123;chalk.dim(shortFile)&#125;</span>`</span>)</span><br><span class="line">  config.<span class="property">logger</span>.<span class="title function_">info</span>(</span><br><span class="line">    chalk.<span class="title function_">green</span>(<span class="string">&#x27;config or .env file changed, restarting server...&#x27;</span>),</span><br><span class="line">    &#123; <span class="attr">clear</span>: <span class="literal">true</span>, <span class="attr">timestamp</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">restartServer</span>(server)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>客户端：websocket通信和更新处理</li>
</ul>
<p>客户端：当我们配置了热更新且不是<code>ssr</code>的时候，<code>Vite</code>底层在处理html的时候会把<code>HMR</code>相关的客户端代码写入在我们的代码中，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasHMR &amp;!ssr) debugHmr <span class="title class_">Evan</span> <span class="title class_">You</span>,a year ago.<span class="property">wip</span>:hmr propagation$&#123; isSelfAccepting[self-accepts] acceptedUrls.<span class="property">size</span>？<span class="string">`[accepts--deps]y:[detected api usage]&#125;<span class="subst">$&#123;prettyImporter&#125;</span>&#x27;/inject hot context str().prepend( import createHotContext as__vite_createHotContext from &quot;s&#123;clientPublicPath&#125;&quot;;+ import.meta.hot =_vite_createHotContext(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify( importerModule.url)&#125;</span>)；</span></span><br></pre></td></tr></table></figure>

<p>当接收到服务端推送的消息，通过不同的消息类型做相应的处理，如(<code>connected</code>、<code>update</code>、<code>custom</code>…)，在实际开发热更新中使用最频繁的是<code>update</code>(动态加载热更新模块)和<code>full-reload</code>(刷新整个页面)事件。</p>
<blockquote>
<p>源码位置：packages&#x2F;vite&#x2F;packages&#x2F;vite&#x2F;src&#x2F;client&#x2F;client.ts</p>
</blockquote>
<p>核心代码实现</p>
<p><img src="/bolg/images/vite/img_06.png" alt="客户端更新处理流程"></p>
<ul>
<li>优化：浏览器的缓存策略提高响应速度</li>
</ul>
<p>同时，<code>Vite</code> 还利用<code>HTTP</code>加速整个页面的重新加载。设置响应头使得依赖模块(<code>dependency module</code>)进行强缓存，而源码文件通过设置 <code>304 Not Modified</code> 而变成可依据条件而进行更新。</p>
<p>若需要对依赖代码模块做改动可手动操作使缓存失效:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`vite --force</span><br></pre></td></tr></table></figure>
<p>或者手动删除 <code>node_modules/.``vite</code> 中的缓存文件。</p>
<p>相关代码实现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /optimizer.ts</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="attr">data</span>: <span class="title class_">DepOptimizationMetadata</span> = &#123;</span><br><span class="line">    <span class="attr">hash</span>: mainHash, <span class="comment">//&quot;9a4fa980&quot;</span></span><br><span class="line">    <span class="attr">browserHash</span>: mainHash, <span class="comment">//&quot;9a4fa980&quot;</span></span><br><span class="line">    <span class="attr">optimized</span>: &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否强制预先优化 不管是否已经更改。</span></span><br><span class="line"><span class="comment">// force = config.server.force 来源于cli.ts，获取命令行参数中是否有 --force</span></span><br><span class="line"><span class="keyword">if</span> (!force) &#123;</span><br><span class="line">  <span class="keyword">let</span> prevData;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试解析已经存在的metadata数据， 获取/.vite/metadata.json中的内容</span></span><br><span class="line">    prevData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(fs.<span class="title function_">readFileSync</span>(dataPath, <span class="string">&#x27;utf-8&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  <span class="comment">// hash is consistent, no need to re-bundle</span></span><br><span class="line">  <span class="comment">// 如果预dep数据的hash相同，那就直接跳过，如果需要覆盖就使用 --force</span></span><br><span class="line">  <span class="keyword">if</span> (prevData &amp;&amp; prevData.<span class="property">hash</span> === data.<span class="property">hash</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;Hash is consistent. Skipping. Use --force to override.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> prevData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 node_modules/.vite 存在，那就清空。</span></span><br><span class="line"><span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(cacheDir)) &#123;</span><br><span class="line">  <span class="title function_">emptyDir</span>(cacheDir);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 要不然就创建文件夹， 并且recursive：true 返回创建文件夹的路径</span></span><br><span class="line">  fs.<span class="title function_">mkdirSync</span>(cacheDir, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="基于esbuild的依赖预编译优化"><a href="#基于esbuild的依赖预编译优化" class="headerlink" title="基于esbuild的依赖预编译优化"></a>基于esbuild的依赖预编译优化</h2><h3 id="为什么需要预构建？"><a href="#为什么需要预构建？" class="headerlink" title="为什么需要预构建？"></a>为什么需要预构建？</h3><ol>
<li><strong>支持<code>commonJS</code>依赖</strong></li>
</ol>
<p>上面提到<code>Vite</code>是基于浏览器原生支持<code>ESM</code>的能力实现的，但要求用户的代码模块必须是<code>ESM</code>模块，因此必须将<code>commonJs</code>的文件提前处理，转化成 <code>ESM</code> 模块并缓存入 <code>node_modules/.vite</code></p>
<ol start="2">
<li><strong>减少模块和请求数量</strong></li>
</ol>
<p>除此之外，我们常用的<code>lodash</code>工具库，里面有很多包通过单独的文件相互导入，而 <code>lodash-es</code>这种包会有几百个子模块，当代码中出现 <code>import &#123; debounce &#125; from &#39;lodash-es&#39;</code> 会发出几百个 <code>HTTP</code> 请求，这些请求会造成网络堵塞，影响页面的加载。</p>
<p><code>Vite</code> 将有许多内部模块的 <code>ESM</code> 依赖关系转换为单个模块，以提高后续页面加载性能。</p>
<p>通过预构建<code>lodash-es</code>成为一个模块，也就只需要一个 <code>HTTP</code> 请求了！</p>
<h3 id="为什么使用Esbuild"><a href="#为什么使用Esbuild" class="headerlink" title="为什么使用Esbuild?"></a>为什么使用<code>Esbuild</code>?</h3><p><img src="/bolg/images/vite/img_07.png" alt="构建速度比较"></p>
<p>这是<code>Esbuild</code>首页的图。新一代的打包工具，提供了与<code>Webpack</code>、<code>Rollup</code>、<code>Parcel</code> 等工具相似的资源打包能力，但在时速上达到10～100倍的差距，耗时是<code>Webpack</code>2%~3%</p>
<ol>
<li><strong>编译运行 VS 解释运行</strong></li>
</ol>
<p>大多数前端打包工具都是基于 <code>JavaScript</code> 实现的，大家都知道<code>JavaScript</code>是解释型语言，边运行边解释。而 <code>Esbuild</code> 则选择使用 <code>Go</code> 语言编写，该语言可以编译为原生代码,在编译的时候都将语言转为机器语言，在启动的时候直接执行即可，在 <code>CPU</code> 密集场景下，<code>Go</code> 更具性能优势。</p>
<ol start="2">
<li><strong>多线程 VS 单线程</strong></li>
</ol>
<p><code>JavaScript</code> 本质上是一门单线程语言，直到引入 <code>WebWorker</code> 之后才有可能在浏览器、<code>Node</code> 中实现多线程操作。就我对<code>Webpack</code>的源码理解，其源码也并未使用 <code>WebWorker</code> 提供的多线程能力。而<code>GO</code>天生的多线程优势。</p>
<ol start="3">
<li><strong>对构建流程进行了优化，充分利用 <code>CPU</code> 资源</strong></li>
</ol>
<h3 id="实现原理？"><a href="#实现原理？" class="headerlink" title="实现原理？"></a>实现原理？</h3><p><code>Vite</code>预编译之后，将文件缓存在<code>node_modules/.vite/</code>文件夹下。根据以下地方来决定是否需要重新执行预构建。</p>
<ul>
<li><p><code>package.json</code>中：<code>dependencies</code>发生变化</p>
</li>
<li><p>包管理器的<code>lockfile</code>（package.lock.json）</p>
</li>
<li><p>可能在 vite.config.js 相关字段中配置过的(optimizeDeps.include)</p>
</li>
<li><p><code>NODE_ENV</code> 的值</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /optimizer.ts </span></span><br><span class="line"><span class="keyword">const</span> lockfileFormats = [<span class="string">&#x27;package-lock.json&#x27;</span>, <span class="string">&#x27;yarn.lock&#x27;</span>, <span class="string">&#x27;pnpm-lock.yaml&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// /optimizer.ts =&gt; getDepHash</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cachedHash</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepHash</span>(<span class="params">root: <span class="built_in">string</span>, config: ResolvedConfig</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cachedHash) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedHash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="title function_">lookupFile</span>(root, lockfileFormats) || <span class="string">&#x27;&#x27;</span>; <span class="comment">//往下滑会有lookupFile函数的解释。</span></span><br><span class="line">  <span class="comment">// 这边已经获取了所有local file array 内的文件内容</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// also take config into account</span></span><br><span class="line">  <span class="comment">// only a subset of config options that can affect dep optimization</span></span><br><span class="line"></span><br><span class="line">  content += <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">mode</span>: config.<span class="property">mode</span>,</span><br><span class="line">      <span class="attr">root</span>: config.<span class="property">root</span>,</span><br><span class="line">      <span class="attr">resolve</span>: config.<span class="property">resolve</span>,</span><br><span class="line">      <span class="attr">assetsInclude</span>: config.<span class="property">assetsInclude</span>,</span><br><span class="line">      <span class="attr">plugins</span>: config.<span class="property">plugins</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p.<span class="property">name</span>),</span><br><span class="line">      <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">        <span class="attr">include</span>: config.<span class="property">optimizeDeps</span>?.<span class="property">include</span>, <span class="comment">// null</span></span><br><span class="line">        <span class="attr">exclude</span>: config.<span class="property">optimizeDeps</span>?.<span class="property">exclude</span>, <span class="comment">//null</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">_, value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span> || value <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.<span class="title function_">toString</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">//这里不说了  最终返回 &quot;9a4fa980&quot; 八位数hash值。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createHash</span>(<span class="string">&#x27;sha256&#x27;</span>).<span class="title function_">update</span>(content).<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>).<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /optimizer.ts =&gt; lookupFile</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lookupFile</span>(<span class="params"></span></span><br><span class="line"><span class="params">  dir: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  formats: <span class="built_in">string</span>[],</span></span><br><span class="line"><span class="params">  pathOnly = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="built_in">string</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> format <span class="keyword">of</span> formats) &#123;</span><br><span class="line">    <span class="keyword">const</span> fullPath = path.<span class="title function_">join</span>(dir, format); <span class="comment">//获取root + format路径</span></span><br><span class="line">    <span class="comment">// 路径对象是否存在 并且是文件</span></span><br><span class="line">    <span class="comment">// pathOnly 为true就只返回路径，不然就都默认返回utf-8的文件内容</span></span><br><span class="line">    <span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(fullPath) &amp;&amp; fs.<span class="title function_">statSync</span>(fullPath).<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> pathOnly ? fullPath : fs.<span class="title function_">readFileSync</span>(fullPath, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> parentDir = path.<span class="title function_">dirname</span>(dir);</span><br><span class="line">  <span class="keyword">if</span> (parentDir !== dir) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">lookupFile</span>(parentDir, formats, pathOnly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果想强制让<code>Vite</code>重新预构建依赖，可以使用<code>--force</code>启动开发服务器，或者直接删掉<code>node_modules/.vite/</code>文件夹。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /optimizer.ts</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="attr">data</span>: <span class="title class_">DepOptimizationMetadata</span> = &#123;</span><br><span class="line">    <span class="attr">hash</span>: mainHash, <span class="comment">//&quot;9a4fa980&quot;</span></span><br><span class="line">    <span class="attr">browserHash</span>: mainHash, <span class="comment">//&quot;9a4fa980&quot;</span></span><br><span class="line">    <span class="attr">optimized</span>: &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否强制预先优化 不管是否已经更改。</span></span><br><span class="line"><span class="comment">// force = config.server.force 来源于cli.ts，获取命令行参数中是否有 --force</span></span><br><span class="line"><span class="keyword">if</span> (!force) &#123;</span><br><span class="line">  <span class="keyword">let</span> prevData;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试解析已经存在的metadata数据， 获取/.vite/metadata.json中的内容</span></span><br><span class="line">    prevData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(fs.<span class="title function_">readFileSync</span>(dataPath, <span class="string">&#x27;utf-8&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  <span class="comment">// hash is consistent, no need to re-bundle</span></span><br><span class="line">  <span class="comment">// 如果预dep数据的hash相同，那就直接跳过，如果需要覆盖就使用 --force</span></span><br><span class="line">  <span class="keyword">if</span> (prevData &amp;&amp; prevData.<span class="property">hash</span> === data.<span class="property">hash</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;Hash is consistent. Skipping. Use --force to override.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> prevData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 node_modules/.vite 存在，那就清空。</span></span><br><span class="line"><span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(cacheDir)) &#123;</span><br><span class="line">  <span class="title function_">emptyDir</span>(cacheDir);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 要不然就创建文件夹， 并且recursive：true 返回创建文件夹的路径</span></span><br><span class="line">  fs.<span class="title function_">mkdirSync</span>(cacheDir, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h4><ol>
<li><p>通过<code>createServer</code>创建<code>server</code>对象后，当服务器启动会执行<code>httpServer.listen</code>方法</p>
</li>
<li><p>在执行<code>createServer</code>时，<code>Vite</code>底层会重写<code>server.listen</code>方法:首先调用插件的<code>buildStart</code>再执行<code>runOptimize()</code>方法</p>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">runOptimize</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="property">cacheDir</span>) &#123;</span><br><span class="line">      server.<span class="property">_isRunningOptimizer</span> = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        server.<span class="property">_optimizeDepsMetadata</span> = <span class="keyword">await</span> <span class="title function_">optimizeDeps</span>(</span><br><span class="line">          config,</span><br><span class="line">          config.<span class="property">server</span>.<span class="property">force</span> || server.<span class="property">_forceOptimizeOnRestart</span></span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        server.<span class="property">_isRunningOptimizer</span> = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      server.<span class="property">_registerMissingImport</span> = <span class="title function_">createMissingImporterRegisterFn</span>(server)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (!middlewareMode &amp;&amp; httpServer) &#123;</span><br><span class="line">  <span class="keyword">let</span> isOptimized = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// overwrite listen to run optimizer before server start</span></span><br><span class="line">  <span class="keyword">const</span> listen = httpServer.<span class="property">listen</span>.<span class="title function_">bind</span>(httpServer)</span><br><span class="line">  httpServer.<span class="property">listen</span> = (<span class="keyword">async</span> (<span class="attr">port</span>: <span class="built_in">number</span>, ...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isOptimized) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> container.<span class="title function_">buildStart</span>(&#123;&#125;)</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">runOptimize</span>()</span><br><span class="line">        isOptimized = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        httpServer.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, e)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">listen</span>(port, ...args)</span><br><span class="line">  &#125;) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> container.<span class="title function_">buildStart</span>(&#123;&#125;)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">runOptimize</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><code>runOptimize()</code>调用<code>optimizeDeps()</code>和<code>createMissingImporterRegisterFn()</code>方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /optimizer.ts</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">optimizeDeps</span>(<span class="params"></span></span><br><span class="line"><span class="params">  config: ResolvedConfig,</span></span><br><span class="line"><span class="params">  force = config.server.force,</span></span><br><span class="line"><span class="params">  asCommand = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">  newDeps?: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; root, logger, cacheDir &#125; = config</span><br><span class="line">   <span class="comment">// 这边第三个args为 asCommand, 是否是命令行运行的</span></span><br><span class="line">   <span class="comment">// 为了讲述的流畅性，在上一章节代码入口没有提到， 在vite --force 后，会直接运行optimizeDeps函数，因此需要区分log的输出方式</span></span><br><span class="line">   <span class="comment">// vite --force    =&gt;    await optimizeDeps(config, options.force, true)</span></span><br><span class="line">  <span class="keyword">const</span> log = asCommand ? logger.<span class="property">info</span> : debug</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cacheDir) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">`No cache directory. Skipping.`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//这边首先获取 预构建模块路径</span></span><br><span class="line">  <span class="keyword">const</span> dataPath = path.<span class="title function_">join</span>(cacheDir, <span class="string">&#x27;_metadata.json&#x27;</span>); <span class="comment">//预缓存路径</span></span><br><span class="line">  <span class="comment">// /.../my-vue-app/node_modules/.vite/_metadata.json</span></span><br><span class="line">  <span class="keyword">const</span> mainHash = <span class="title function_">getDepHash</span>(root, config);</span><br><span class="line">  <span class="comment">// 创建一个data的对象，后面会用到</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">data</span>: <span class="title class_">DepOptimizationMetadata</span> = &#123;</span><br><span class="line">    <span class="attr">hash</span>: mainHash,</span><br><span class="line">    <span class="attr">browserHash</span>: mainHash,</span><br><span class="line">    <span class="attr">optimized</span>: &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>optimizeDeps()</code>主要是根据配置文件生成<code>hash</code>，获取上次预购建的内容(存放在<code>_metadata.json</code>文件)。如果不是强预构建就对比<code>_metadata.json</code>文件的<code>hash</code>和新生成的<code>hash</code>：一致就返回<code>_metadata.json</code>文件的内容，否则清空缓存文件调用<code>Esbuild</code>构建模块再次存入<code>_metadata.json</code>文件</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_modules/.vite/_metadata.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;hash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9a4fa980&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;browserHash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6f00d484&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;optimized&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/.../my-vue-app/node_modules/.vite/vue.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/.../my-vue-app/node_modules/vue/dist/vue.runtime.esm-bundler.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;needsInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;axios&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/.../new/my-vue-app/node_modules/.vite/axios.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/.../new/my-vue-app/node_modules/axios/index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;needsInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="整体的流程图"><a href="#整体的流程图" class="headerlink" title="整体的流程图"></a>整体的流程图</h4><blockquote>
<p>核心代码都在<code>packages/vite/src/node/optimizer/index.ts</code>里面</p>
</blockquote>
<ul>
<li>自动搜寻依赖主要模块：<code>esbuildScanPlugin</code>，导出模块依赖关系对象<code>deps</code>和未找到模块路径对象<code>missing</code></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /optimizer.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">deps</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;, <span class="attr">missing</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// 在服务器已经启动之后，如果遇到一个新的依赖关系导入，</span></span><br><span class="line"><span class="comment">// 而这个依赖关系还没有在缓存中，Vite 将重新运行依赖构建进程并重新加载页面。</span></span><br><span class="line"><span class="comment">// 如上官方文档所述，最终会得出deps 和missing</span></span><br><span class="line"><span class="keyword">if</span> (!newDeps) &#123;</span><br><span class="line">  <span class="comment">// scanImports 这里就不展开了，他的作用就是获取导入源，用正则检测后，使用esbuild编译所有的入口依赖（entries)</span></span><br><span class="line">  (&#123; deps, missing &#125; = <span class="keyword">await</span> <span class="title function_">scanImports</span>(config));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  deps = newDeps;</span><br><span class="line">  missing = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写更新了浏览器的哈希</span></span><br><span class="line"><span class="comment">// update browser hash</span></span><br><span class="line">data.<span class="property">browserHash</span> = <span class="title function_">createHash</span>(<span class="string">&#x27;sha256&#x27;</span>)</span><br><span class="line">  .<span class="title function_">update</span>(data.<span class="property">hash</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(deps))</span><br><span class="line">  .<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">  .<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>预构建编译主要模块：<code>esbuildDepPlugin</code> 里面的（<code>es-module-lexer</code>,<code>Magic-string</code>）裸模块重写，需要对模块加载地址进行重写操作</li>
</ul>
<p><img src="/bolg/images/vite/img_08.png" alt="预构建流程图"></p>
<ol>
<li>获取了预构建模块的内容（hash 值，优化对象等）。</li>
<li>获取包管理器的 lockfile 转换的 hash 值，判断是否需要重新运行预构建。</li>
<li>获取需要编译依赖关系的模块路径（deps）和需要编译但没找到来源的模块（missing)。</li>
<li>处理 missing 数组，打印 error 提示是否已安装来源。</li>
<li>获取 vite.config.js 中自定义强制预构建的模块路径(include)，加入 deps 对象中。</li>
<li>命令行打印需要构建模块的信息。</li>
<li>创建预构建对象，获取预构建对象中的引入导出数据并记录。</li>
</ol>
<h2 id="基于Rollup的-Plugins"><a href="#基于Rollup的-Plugins" class="headerlink" title="基于Rollup的 Plugins"></a>基于Rollup的 Plugins</h2><p><code>Vite</code> 从 <code>preact</code> 的 <code>WMR</code> 中得到了启发，将<code>Vite Plugins</code>继承<code>Rollup Plugins API</code>，在其基础上进行了一些扩展(如<code>Vite</code>特有的钩子等)，同时<code>Vite</code>也基于<code>Rollup plugins</code>机制提供了强大的插件<code>API</code>。目前和 <code>Vite</code> 兼容或者内置的插件，可以查看<code>vite-rollup-plugins</code></p>
<h3 id="Vite插件是什么"><a href="#Vite插件是什么" class="headerlink" title="Vite插件是什么"></a>Vite插件是什么</h3><p>使用<code>Vite</code>插件可以扩展<code>Vite</code>能力，通过暴露一些构建打包过程的一些时机配合工具函数，让用户可以自定义地写一些配置代码，执行在打包过程中。比如解析用户自定义的文件输入，在打包代码前转译代码，或者查找。</p>
<p>在实际的实现中，<code>Vite</code> 仅仅需要基于<code>Rollup</code>设计的接口进行扩展，在保证兼容 <code>Rollup</code>插件的同时再加入一些<code>Vite</code>特有的钩子和属性来进行扩展。</p>
<h3 id="Vite独有钩子"><a href="#Vite独有钩子" class="headerlink" title="Vite独有钩子"></a>Vite独有钩子</h3><p>对于各个钩子的具体使用可以<a href="https://cn.vitejs.dev/guide/api-plugin.html#vite-specific-hooks">移步这里</a></p>
<ul>
<li><p><code>config</code>：可以在<code>Vite</code>被解析之前修改<code>Vite</code>的相关配置。钩子接收原始用户配置<code>config</code>和一个描述配置环境的变量<code>env</code></p>
</li>
<li><p><code>configResolved</code>：解析<code>Vite</code>配置后调用，配置确认</p>
</li>
<li><p><code>configureserver</code>：主要用来配置开发服务器，为<code>dev-server</code>添加自定义的中间件</p>
</li>
<li><p><code>transformindexhtml</code>：主要用来转换<code>index.html</code>，钩子接收当前的 <code>HTML</code> 字符串和转换上下文</p>
</li>
<li><p><code>handlehotupdate</code>：执行自定义<code>HMR</code>更新，可以通过<code>ws</code>往客户端发送自定义的事件</p>
</li>
</ul>
<h3 id="通用钩子"><a href="#通用钩子" class="headerlink" title="通用钩子"></a>通用钩子</h3><p>这里举一些常用的通用钩子，其余的通用钩子可以<a href="https://cn.vitejs.dev/guide/api-plugin.html#universal-hooks">移步这里</a></p>
<ul>
<li><p>服务启动时调用一次</p>
<ol>
<li><code>options</code>: 获取、操纵<code>Rollup</code>选项</li>
<li><code>buildstart</code>：开始创建</li>
</ol>
</li>
<li><p>在每个传入模块请求时被调用</p>
<ol>
<li><code>resolveId</code>: 创建自定义确认函数，可以用来定位第三方依赖</li>
<li><code>load</code>：可以自定义加载器，可用来返回自定义的内容</li>
<li><code>transform</code>：在每个传入模块请求时被调用，主要是用来转换单个模块</li>
</ol>
</li>
<li><p>服务关闭时调用一次</p>
<ol>
<li><code>buildend</code>：在服务器关闭时被调用</li>
<li><code>closeBundle</code></li>
</ol>
</li>
</ul>
<h5 id="钩子的调用顺序"><a href="#钩子的调用顺序" class="headerlink" title="钩子的调用顺序"></a>钩子的调用顺序</h5><p><code>Vite</code><a href="https://cn.vitejs.dev/guide/api-plugin.html#plugin-ordering">的官网</a>可以看出：<code>Vite</code>插件可以用一个 <code>enforce</code> 属性（类似于 <code>Webpack</code>加载器）来调整它的应用顺序。<code>enforce</code> 的值可以是<code>pre</code> 或 <code>post</code>。解析后的插件将按照以下顺序排列：</p>
<ul>
<li><p><code>Alias</code></p>
</li>
<li><p><code>enforce:&#39;pre&#39;</code>的自定义插件</p>
</li>
<li><p><code>Vite</code>核心插件</p>
</li>
<li><p>没有<code>enforce</code>的自定义插件</p>
</li>
<li><p><code>Vite</code>构建用的插件</p>
</li>
<li><p><code>enforce:&#39;post&#39;</code>的自定义插件</p>
</li>
<li><p><code>Vite</code>后置构建插件</p>
</li>
</ul>
<h5 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h5><ul>
<li>编写插件代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">myVitePlugin</span> () &#123;</span><br><span class="line">  <span class="comment">// 定义vite插件唯一id</span></span><br><span class="line">  <span class="keyword">const</span> virtualFileId = <span class="string">&#x27;@my-vite-plugin&#x27;</span></span><br><span class="line">  <span class="comment">// 返回的整个插件对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 必须的，将会显示在 warning 和 error 中</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;vite-plugin&#x27;</span>,</span><br><span class="line">    <span class="comment">// 钩子</span></span><br><span class="line">    <span class="comment">// config</span></span><br><span class="line">    <span class="attr">config</span>: <span class="function">(<span class="params">config, env</span>) =&gt;</span> (&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;config&#x27;</span>,config)</span><br><span class="line">       <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 确认config</span></span><br><span class="line">    <span class="attr">configResolved</span>: <span class="function"><span class="params">config</span> =&gt;</span> (&#123;&#125;),</span><br><span class="line">    <span class="attr">options</span>: <span class="function"><span class="params">options</span> =&gt;</span> (&#123;&#125;),</span><br><span class="line">    <span class="attr">buildStart</span>: <span class="function"><span class="params">options</span> =&gt;</span> (&#123;&#125;),</span><br><span class="line">    <span class="attr">transformIndexHtml</span>: <span class="function">(<span class="params">html, ctx</span>) =&gt;</span> (&#123;</span><br><span class="line">        <span class="keyword">return</span> html</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">//确认</span></span><br><span class="line">    <span class="attr">resolveId</span>: <span class="function">(<span class="params">source, importer</span>) =&gt;</span> (&#123;&#125;),</span><br><span class="line">    <span class="comment">// 转换</span></span><br><span class="line">    <span class="attr">transform</span>: <span class="function">(<span class="params">code, id</span>) =&gt;</span> (&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>引入插件：<code>vite.config.js/ts</code> 中引用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.js/ts</span></span><br><span class="line"><span class="keyword">import</span> myVitePlugin <span class="keyword">from</span> <span class="string">&#x27;...&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig&#123;</span><br><span class="line">    <span class="attr">plugins</span>:[<span class="title function_">vue</span>(),<span class="title function_">myVitePlugin</span>()]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结下<code>Vite</code>相关的优缺点：</p>
<ul>
<li><p>优点：</p>
<ol>
<li>快速的冷启动: 采用<code>No Bundle</code>和<code>esbuild</code>预构建，速度远快于<code>Webpack</code></li>
<li>高效的热更新：基于<code>ESM</code>实现，同时利用<code>HTTP</code>头来加速整个页面的重新加载，增加缓存策略</li>
<li>真正的按需加载: 基于浏览器<code>ESM</code>的支持，实现真正的按需加载</li>
</ol>
</li>
<li><p>缺点:</p>
<ol>
<li>生态：目前<code>Vite</code>的生态不如<code>Webapck</code>，不过我觉得生态也只是时间上的问题。</li>
<li>生产环境由于<code>esbuild</code>对<code>css</code>和代码分割不友好使用<code>Rollup</code>进行打包</li>
</ol>
</li>
</ul>
<p><code>Vite.js</code>虽然才在构建打包场景兴起，但在很多场景下基本都会优于现有的解决方案。如果有生态、想要丰富的<code>loader</code>、<code>plugins</code>的要求可以考虑成熟的<code>Webpack</code>。在其余情况下，<code>Vite.js</code>不失为一个打包构建工具的好选择。</p>
]]></content>
  </entry>
  <entry>
    <title>深入理解防抖和节流</title>
    <url>/bolg/2024/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>防抖</code>和<code>节流</code>是前端开发中常用的函数优化手段，它们可以限制函数的执行频率，提升性能和用户体验。主要用于处理高频触发的事件，例如：用户的滚动、输入、点击和表单的重复提交等。</p>
<h1 id="防抖与节流的区别"><a href="#防抖与节流的区别" class="headerlink" title="防抖与节流的区别"></a>防抖与节流的区别</h1><p>先简单描述下它们的作用</p>
<ul>
<li><p>防抖：如果一个函数持续地、频繁地触发，那么只在它结束后过一段时间才开始执行。换句话说，如果你持续触发事件，那么防抖函数将不会执行，只有当你停止触发事件后，它才会在指定的延迟时间后执行。这对于防止例如用户在输入框中连续输入时发送过多的Ajax请求等情况非常有用。</p>
</li>
<li><p>节流：如果你持续触发事件，每隔一段时间，事件处理函数只执行一次。这有助于限制一些处理函数的执行频率，例如：滚动事件、窗口大小调整事件等。</p>
</li>
</ul>
<p>简而言之，防抖是在事件停止触发后延迟执行函数，而节流是按照固定的时间间隔执行函数。</p>
<p>因为<code>防抖</code>和<code>节流</code>的作用和应用场景基本相同，也就导致它们容易被混淆。</p>
<h2 id="防抖的实现与使用"><a href="#防抖的实现与使用" class="headerlink" title="防抖的实现与使用"></a><strong>防抖的实现与使用</strong></h2><p>防抖的应用场景：</p>
<ol>
<li>输入框搜索：当用户在搜索框中输入关键字时，使用防抖可以避免频繁发送搜索请求，而是在用户停止输入一段时间后才发送请求，减轻服务器压力。</li>
<li>按钮点击：当用户点击按钮时，使用防抖可以避免用户多次点击造成的多次提交或重复操作。</li>
</ol>
<p>实现防抖的基本方式是利用定时器，每次触发事件时都清除上一次的定时器，然后重新设置一个新的定时器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 防抖函数  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> timeout;  </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> context = <span class="variable language_">this</span>;  </span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">clearTimeout</span>(timeout);  </span></span><br><span class="line"><span class="language-javascript">                timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> func.<span class="title function_">apply</span>(context, args), wait);  </span></span><br><span class="line"><span class="language-javascript">            &#125;;  </span></span><br><span class="line"><span class="language-javascript">        &#125;  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用防抖函数控制连续触发事件的处理函数执行频率  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> debouncedHandler = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Debounced event triggered&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">500</span>);  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,debouncedHandler)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="节流的实现与使用"><a href="#节流的实现与使用" class="headerlink" title="节流的实现与使用"></a>节流的实现与使用</h1><p>节流的应用场景：</p>
<ol>
<li>页面滚动：当页面滚动时，使用节流可以限制滚动事件的触发频率，减少事件处理的次数，提高页面的响应性能。</li>
<li>按钮点击：当用户点击按钮时，使用节流可以减少事件处理的次数，避免过于频繁的操作。</li>
</ol>
<p>实现节流的方式也是利用定时器，但与防抖不同的是，节流会保证在一个固定的时间间隔内至少执行一次事件处理函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       </span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 节流函数  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, limit</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> inThrottle;  </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> context = <span class="variable language_">this</span>;  </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (!inThrottle) &#123;  </span></span><br><span class="line"><span class="language-javascript">                func.<span class="title function_">apply</span>(context, args);  </span></span><br><span class="line"><span class="language-javascript">                inThrottle = <span class="literal">true</span>;  </span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> inThrottle = <span class="literal">false</span>, limit);  </span></span><br><span class="line"><span class="language-javascript">                &#125;  </span></span><br><span class="line"><span class="language-javascript">            &#125;;  </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用节流函数控制连续触发事件的处理函数执行频率  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> throttledHandler = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Throttled event triggered&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,throttledHandler)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在实际的前端开发中，防抖和节流的使用场景非常广泛。例如：搜索框的实时搜索建议可以使用防抖来减少服务器请求；滚动加载更多数据可以使用节流来防止在短时间内发送过多的请求。通过使用这两种技术，我们可以有效地优化前端的性能，提升用户体验。</p>
<p>本文转自 <a href="https://juejin.cn/post/7324522555268366351?searchId=202403011646443E84D49F22E455869CE8">https://juejin.cn/post/7324522555268366351?searchId=202403011646443E84D49F22E455869CE8</a>，如有侵权，请联系删除。</p>
]]></content>
  </entry>
  <entry>
    <title>神经网络入门</title>
    <url>/bolg/2024/03/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="何为张量？"><a href="#何为张量？" class="headerlink" title="何为张量？"></a>何为张量？</h1><blockquote>
<p>仅包含一个数字的张量叫做标量（<code>scalar</code>也叫标量, 零维张量,<strong>0D张量</strong>）。<br>在<code>Numpy</code>中，一个<code>float32</code>或者<code>float64</code>的数字就是一个标量张量（或者标量数组）。你可以用<code>ndim</code>属性<br>来查看张量的轴数.</p>
</blockquote>
<h2 id="0D张量（标量）"><a href="#0D张量（标量）" class="headerlink" title="0D张量（标量）"></a>0D张量（标量）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">np.array(12)</span><br></pre></td></tr></table></figure>
<h2 id="1D张量（向量）"><a href="#1D张量（向量）" class="headerlink" title="1D张量（向量）"></a>1D张量（向量）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure>
<h2 id="2D张量（矩阵）"><a href="#2D张量（矩阵）" class="headerlink" title="2D张量（矩阵）"></a>2D张量（矩阵）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表示3x5长度的矩阵</span></span><br><span class="line">np.array([[<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">79</span>,<span class="number">3</span>,<span class="number">35</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="3D张量和更高维的张量"><a href="#3D张量和更高维的张量" class="headerlink" title="3D张量和更高维的张量"></a>3D张量和更高维的张量</h2><ul>
<li>5D向量–表示一个轴有五个数值</li>
<li>5D张量–表示有五个轴<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([</span><br><span class="line">        [[<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">79</span>,<span class="number">3</span>,<span class="number">35</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">2</span>]],</span><br><span class="line">        [[<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">79</span>,<span class="number">3</span>,<span class="number">35</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">2</span>]],</span><br><span class="line">        [[<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">79</span>,<span class="number">3</span>,<span class="number">35</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">2</span>]]</span><br><span class="line">      ])</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="张量的关键属性"><a href="#张量的关键属性" class="headerlink" title="张量的关键属性"></a>张量的关键属性</h2><ul>
<li>ndim（轴的个数）</li>
<li>形状 &#x3D;&gt; 3D形状(3,3,5)&#x3D;&gt;表示3个3x5的矩阵</li>
<li>数据类型–<code>float32</code>(例如：MINIST的数据集为由8位整数组成的3D张量,每个矩阵都表示为灰度图像)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###从train_image数据集中抽（90,28,28）的图像</span></span><br><span class="line">train_image[<span class="number">10</span>:<span class="number">100</span>]==train_image[<span class="number">10</span>:<span class="number">100</span>,:,:]==train_image[<span class="number">10</span>:<span class="number">100</span>,<span class="number">0</span>:<span class="number">28</span>,<span class="number">0</span>:<span class="number">28</span>]</span><br><span class="line"><span class="comment">####截取所有图片14x14的图像</span></span><br><span class="line">train_image[:,<span class="number">14</span>:,<span class="number">14</span>:]</span><br><span class="line"><span class="comment">####截取所有图片中心截取14x14的图像</span></span><br><span class="line">train_image[:,<span class="number">7</span>:-<span class="number">7</span>,<span class="number">7</span>:-<span class="number">7</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="现实中物体如何用张量表示"><a href="#现实中物体如何用张量表示" class="headerlink" title="现实中物体如何用张量表示"></a>现实中物体如何用张量表示</h2><ul>
<li>向量数据：2D–形状(samples,features)</li>
<li>时间序列或序列数据：3D张量, (samples,timesteps,features)</li>
<li>图像：4D –(samples,height,width,channels)</li>
<li>视频:5D –(samples,frames,height,width,channels)</li>
</ul>
<h2 id="训练模型用到哪些数据集"><a href="#训练模型用到哪些数据集" class="headerlink" title="训练模型用到哪些数据集"></a>训练模型用到哪些数据集</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ol>
<li>非张量数据类型需要做数据转换，实际操作例如<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mean=train_data.mean(axis=<span class="number">0</span>)</span><br><span class="line">train_data-=mean</span><br><span class="line">std=train_data.std(axis=<span class="number">0</span>)</span><br><span class="line">train_data/ =std</span><br><span class="line"></span><br><span class="line">test_data-=mean</span><br><span class="line">test_data/=std</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h3><ol>
<li>训练集留出验证集来防止信息泄露<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_validation_samples=<span class="number">10000</span></span><br><span class="line"><span class="comment">##需要打乱数据</span></span><br><span class="line">np.random.suffle(data)</span><br><span class="line"><span class="comment">##定义验证集</span></span><br><span class="line">validatation_data=data[:numvalidation_samples]</span><br><span class="line">data=data[num_validation_samples:]</span><br><span class="line">   <span class="comment">##定义训练集</span></span><br><span class="line"> training_data=data[:]</span><br><span class="line"> 训练集训练模型</span><br><span class="line"> 验证集评估模型</span><br><span class="line"> model=get_model()</span><br><span class="line"> model.train(training_data)</span><br><span class="line"> validation_score=model.evaluate(validation_data)</span><br><span class="line"> <span class="comment">#现在你可以调节模型、重新训练、评估，然后再次调节....</span></span><br><span class="line"> model=get_model()                   					   			model.train(np.concatence([training_data,validation_data]))</span><br><span class="line">  test_score=model.evaluate(test_data)</span><br><span class="line"> <span class="comment">###一旦调节号超参数，通常就在所有非测试数据上从头开始训练最终模型</span></span><br></pre></td></tr></table></figure></li>
<li>训练过程超参数调优<ul>
<li>使用tensorBoard和keras可视化训练过程</li>
<li>使用批量和小批量工作 –早停方法防止过拟合</li>
<li>使用网格搜索调整参数 –Hyperopt</li>
<li>学习率和学习率调度</li>
<li>比较优化器</li>
<li>确定网络的深度</li>
<li>添加Dropout以防止过拟合</li>
<li>通过数据增广使模型更好</li>
<li>利用TTA来提高精度</li>
</ul>
</li>
<li>利用keras框架中的tensorBoard<code>callbacks=[EarlyStopping()]回调函数</code></li>
<li>分析网络内部结构<ul>
<li>用tensorBoard可视化训练结构</li>
<li>用tensorBoard可视化网络结构</li>
<li>分析网络权重</li>
<li>冻结层</li>
<li>存储网络结构并训练权重</li>
</ul>
</li>
</ol>
<h3 id="验证集"><a href="#验证集" class="headerlink" title="验证集"></a>验证集</h3><ol>
<li>通过K折验证算法打乱验证集<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k=<span class="number">4</span></span><br><span class="line">num_validation_samples=<span class="built_in">len</span>(data) //k</span><br><span class="line">np.random.shuffle(data)</span><br><span class="line">validation_scores=[]</span><br><span class="line"><span class="keyword">for</span> fold <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line"><span class="comment">###选择验证集区域</span></span><br><span class="line">    validation_data=data[num_validaion_samples * fold:</span><br><span class="line">    num_validation_samples*(fold+<span class="number">1</span>)]</span><br><span class="line">    <span class="comment">###使用剩余数据作为训练数据，注意，+运算符是列表合并，不是求和</span></span><br><span class="line">    train_data=data[:num_validation_samples*fold]+data[num_validation_samples*(fold+<span class="number">1</span>):]</span><br><span class="line">    <span class="comment">##创建一个全新的模型</span></span><br><span class="line">    model=get_model()</span><br><span class="line">    model.train(training_data)</span><br><span class="line">    validation_score=model.evaluate(validation_data)</span><br><span class="line">    validation_scores.append(validation_score)</span><br><span class="line">    <span class="comment">##k折取平均值</span></span><br><span class="line">    validation_score=np.average(validation_scores)</span><br><span class="line"> <span class="comment">#在非测试集上训练最终的模型</span></span><br><span class="line"> model=get_model()</span><br><span class="line"> model.train(data)</span><br><span class="line"> test_score=model.evaluate(test_data)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="层"><a href="#层" class="headerlink" title="层"></a>层</h1><blockquote>
<p>包含数据的变换和权重</p>
</blockquote>
<h2 id="如何定义输入层和输出层"><a href="#如何定义输入层和输出层" class="headerlink" title="如何定义输入层和输出层"></a>如何定义输入层和输出层</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">####输出32个密集层</span></span><br><span class="line">model.add(Dense(<span class="number">32</span>,input_shape=<span class="number">784</span>))</span><br><span class="line"><span class="comment">####默认为上一个输出层的输出当作下一层输入</span></span><br><span class="line">model.add(Dense(<span class="number">32</span>))</span><br></pre></td></tr></table></figure>

<h2 id="层在训练过程如何优化"><a href="#层在训练过程如何优化" class="headerlink" title="层在训练过程如何优化"></a>层在训练过程如何优化</h2><p>在训练的过程中需要将损失函数（目标函数）最小化，不同的训练类型有不同的处理</p>
<ol>
<li>二类分类（binary cossentropy）</li>
<li>多分类(categorial cossentropy)</li>
</ol>
<ul>
<li>采用优化器（<code>adm，rmsprop，sgd</code>）提高学习率</li>
</ul>
<ol start="3">
<li>回归问题(mean-squared error)</li>
</ol>
<ul>
<li>采用激活函数将线性转为非线性</li>
</ul>
<ol start="4">
<li>联结主义时序分类(CTC)</li>
<li>其他场景</li>
</ol>
<ul>
<li>将整数数列编码为二进制矩阵</li>
</ul>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vectorize_sequences</span>(<span class="params">sequences,dimension=<span class="number">10000</span></span>):</span><br><span class="line">  <span class="comment">#零矩阵</span></span><br><span class="line">  res=np.zeros((<span class="built_in">len</span>(sequences),dimension))</span><br><span class="line">  <span class="keyword">for</span> i,sequences <span class="keyword">in</span> <span class="built_in">enumerate</span>(sequences)：</span><br><span class="line">   <span class="comment">#res[i]的制定索引设为1</span></span><br><span class="line">   res[i,sequences]=<span class="number">1</span></span><br><span class="line"><span class="comment">###标签向量化</span></span><br><span class="line">np.asarray(train_lables).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>绘制训练损失和验证损失数据分析图防止过拟合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">history_dic=history.history</span><br><span class="line">loss_values=history_dic[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss_values=history_dic[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs=<span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(loss_values)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs,loss_values,<span class="string">&#x27;bo&#x27;</span>,label=<span class="string">&#x27;training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs,loss_values,<span class="string">&#x27;b&#x27;</span>,label=<span class="string">&#x27;val loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;loss&quot;</span>)</span><br><span class="line">plt.xlabes(<span class="string">&quot;epochs&quot;</span>)</span><br><span class="line">plt.xlabes(<span class="string">&quot;loss&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="如何定义卷积的参数"><a href="#如何定义卷积的参数" class="headerlink" title="如何定义卷积的参数"></a>如何定义卷积的参数</h2><ul>
<li><p>从输入中提取的图块尺寸–3x3</p>
</li>
<li><p>输出特征图的深度，例如第一层深度32</p>
</li>
<li><p>输出的高度和宽度可与输入的宽度和高度不同，不同的原因有两点</p>
<ol>
<li>边界效应–可以输入特征图进行填充</li>
<li>输出特征图的空间维度与输入相同–使用填充（padding）</li>
<li>最大池化运算</li>
</ol>
</li>
<li><p>数据预处理</p>
</li>
</ul>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDateGenerator</span><br><span class="line"><span class="comment">###将所以图像乘以1/255缩放</span></span><br><span class="line">train_datagen=ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line">test_datagen=ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line"> train_generator=train_datagen.flow_from_directory(</span><br><span class="line">   train_dir,<span class="comment">##目标目录</span></span><br><span class="line">   target_size=(<span class="number">150</span>,<span class="number">150</span>),<span class="comment">##将所以图像大小调整150x150</span></span><br><span class="line">   batch_size=<span class="number">20</span>,</span><br><span class="line">   class_mode=<span class="string">&#x27;binary&#x27;</span><span class="comment">###因为用到binary_crossentropy</span></span><br><span class="line"> )</span><br><span class="line"> valiation_generator=test_datagen.flow_from_directory(</span><br><span class="line">   train_dir,<span class="comment">##目标目录</span></span><br><span class="line">   target_size=(<span class="number">150</span>,<span class="number">150</span>),<span class="comment">##将所以图像大小调整150x150</span></span><br><span class="line">   batch_size=<span class="number">20</span>,</span><br><span class="line">   class_mode=<span class="string">&#x27;binary&#x27;</span><span class="comment">###因为用到binary_crossentropy</span></span><br><span class="line"> )</span><br><span class="line"> <span class="comment">##python 生成器</span></span><br><span class="line"> history=model.fit_generator(</span><br><span class="line">   train_generator,</span><br><span class="line">   steps_per_epoch=<span class="number">100</span>,</span><br><span class="line">   epochs=<span class="number">30</span>,</span><br><span class="line">   validation_data=validatation_generator,</span><br><span class="line">   validation_steps=<span class="number">50</span></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="如何使用预训练的卷积神经网络"><a href="#如何使用预训练的卷积神经网络" class="headerlink" title="如何使用预训练的卷积神经网络"></a>如何使用预训练的卷积神经网络</h2><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><blockquote>
<p>特征提取就是提取之前训练好的网络的卷积基，在上面运行新的数据，然后再输出的上面训练一个新的分类器</p>
</blockquote>
<ol>
<li>VGG16模型参数详解</li>
</ol>
<ul>
<li>weights：模块初始化检查点</li>
<li>include_top: 是否使用自带的密集器</li>
<li>input_shape: 网络输入图像的形状，可选–处理任意的图像形状</li>
</ul>
<p>例如：使用数据增强的特征提取–建议运行GPU上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">model=model.Sequential()</span><br><span class="line">model.add(conv_base)</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">256</span>,activatiion=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">256</span>,activatiion=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"><span class="comment">##在keras中，冻结网络的方法是将其trainable属性设置为false</span></span><br><span class="line"></span><br><span class="line">conv_base.trainable=false</span><br><span class="line"><span class="comment">##编译使其生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##数据增加</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>微调模型</li>
</ol>
<p>微调是指将其顶部的几层解冻，并将折解冻的几层和新增加的部分联合训练，在已经训练好的基网络上添加自定义网络，冻结基网络，训练所添加的部分，解冻基网络的一些层，联合训练解冻的这些层和添加的部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###冻结直到某一层的所有层</span></span><br><span class="line">conv_base.trainable=true</span><br><span class="line">set_trainable=false</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> conv_base.layers:</span><br><span class="line">    <span class="keyword">if</span> layer.name == <span class="string">&#x27;block5_conv1&#x27;</span>:</span><br><span class="line">       set_trainable=<span class="literal">True</span></span><br><span class="line">     <span class="keyword">if</span> set_trainable:</span><br><span class="line">        layer.trainable=true</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">         layer.trainable=false      </span><br><span class="line"><span class="comment">##微调模型</span></span><br><span class="line">  model.<span class="built_in">compile</span>(</span><br><span class="line">  loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">  optimizer=optimizers.RMSprop(lr=<span class="number">1e-5</span>),</span><br><span class="line">  metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">  history=model.fit_generator(</span><br><span class="line">    train_generator,</span><br><span class="line">    steps_per_epoch=<span class="number">100</span>,</span><br><span class="line">    epochs=<span class="number">100</span>,</span><br><span class="line">    validation_data=validation_generator,</span><br><span class="line">    validation_steps=<span class="number">50</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h2 id="卷积神经网络的可视化"><a href="#卷积神经网络的可视化" class="headerlink" title="卷积神经网络的可视化"></a>卷积神经网络的可视化</h2><ul>
<li>可视化卷积神经网络的中间输出（中间激活）:有助于理解卷积神经网络连续的层如何对输入进行变换，也有助于初步了解卷积网络每个过滤器的含义</li>
<li>可视化卷积神经网络的过滤器：有助于精确理解卷积神经网络中每个过滤器容易接受的视觉模式或视觉概念</li>
<li>可视化图像中类激活的热力图：有助于理解图像的那个部分被识别为属于某个类别，从而可以定位图像的物体—特别用于分类出错的情况</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>实时检测框架，能够快速的检测物体的模型<ul>
<li>faster-RCNN –精准</li>
<li>YOKLO –更快检测</li>
<li>SSD –单发多盒检测器</li>
</ul>
</li>
<li>训练图像的掩膜<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_examples=<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_examples):</span><br><span class="line">   plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">   image=cv2.imread(filename[i])</span><br><span class="line">   image=cv2.cvtColor(image,cv2.COLOR_RGB2RGB)</span><br><span class="line">   plt.imshow(image)</span><br><span class="line"></span><br><span class="line">   plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">   mask_file=filename[i].replace(<span class="string">&#x27;src_color&#x27;</span>,<span class="string">&#x27;human_seg&#x27;</span>)</span><br><span class="line">   mask=cv2.imread(glob.glob(mask_file[:-<span class="number">4</span>]+<span class="string">&#x27;*&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">   ret,mask=cv2.threshold(mask,<span class="number">0.255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">   mask=mask[:<span class="number">0</span>]</span><br><span class="line">   plt.imshow((mask),camp=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure></li>
<li>图像分割分类—U-net</li>
<li>寻找人脸面部关键点</li>
</ol>
<ul>
<li>传统计算机视觉中最常用的应用之一时检测图像中的人脸</li>
<li>第一步检测图像（或帧）中的面部关键点</li>
<li>HOG+线性SVM等传统计算机视觉技术和机器学习技术任然被使用</li>
<li>头部姿态、脸部变形以及使用opencv进行跟踪</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>带有relu的dense层堆叠，可以解决很多种问题（包括情感分析问题）</p>
</li>
<li><p>对于二类问题（两个输出类别），网络的最后一层应该是只有一个单元使用sigmoid激活的dense层，网络输出应该是0-1范围内的标量，表示概率</p>
</li>
<li><p>对于二分类问题的sigmoid标量输出，你应该使用binary_cossesntropy损失函数</p>
</li>
<li><p>无论你的问题是什么，rmsprop优化器通常都是足够号的选择。这一点无须担心。</p>
</li>
<li><p>如果要对n个类别的数据点进行分类，那么最后一层应该是n个dense层</p>
</li>
<li><p>对于单标签。多分类问题，网络的最后一层应该使用softmax函数激活，输出类别的概率分布</p>
</li>
<li><p>处理多分类问题的标签有两种方法</p>
</li>
<li><p>分类编码（one-hot编码）对标签进行编码（y_lables）然后使用categorical_crossentropy作为损失函数<br>将标签编码为整数，然后使用spare_categroical_crossentropy损失函数<br>如果你需要将数据划分到许多分类种，应该避免使用太小的中间层，以免网络中造成信息瓶颈</p>
</li>
<li><p>题使用的损失函数与分类问题不同。回归常用的损失函数是均方差。</p>
</li>
<li><p>归问题使用的评估指标也与分类问题不同，显而易见，精度的概念不适用于回归问题。常见的回归指标是平均绝对误差（mae）</p>
</li>
<li><p>数据的特征具有不同的取值范围，应该先进行预处理，对每个特征单独进行缩放</p>
</li>
<li><p>的数据很少，使用k折验证可以可靠的评估模型</p>
</li>
<li><p>的训练很少，最好使用隐藏层较少（通常只有一到两个的小型网络），以避免过拟合</p>
</li>
<li><p>评估模型注意点</p>
<ul>
<li>数据代表性–随机打乱数据</li>
<li>时间箭头–不可打乱数据，测试机的时间晚于训练集的数据</li>
<li>数据冗余–训练集和数据集不能有交集</li>
<li>数据标准化–每个特征的取值范围不一致</li>
</ul>
</li>
<li><p>数据必须向量化</p>
</li>
<li><p>处理缺失值–不是所有样本都有这个特征</p>
</li>
<li><p>无法确认模型是否强大–就必须开发过拟合的模型</p>
<ul>
<li>添加更多的层</li>
<li>让每一层变得更大</li>
<li>训练更多的轮次</li>
<li>出现过拟合然后进行优化和调参，监督其参数的变化</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
</search>
