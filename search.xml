<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js如何管理内存</title>
    <url>/2024/03/01/js%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>JS的内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。<br>其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。</p>
<h1 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h1><ol>
<li>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。</li>
<li>栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。</li>
<li>由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。</li>
<li>为了得到栈底的元素，必须先拿掉上面的元素。</li>
</ol>
<h1 id="堆数据结构"><a href="#堆数据结构" class="headerlink" title="堆数据结构"></a>堆数据结构</h1><ol>
<li>堆是一种经过排序的树形数据结构，每个结点都有一个值。</li>
<li>通常我们所说的堆的数据结构，是指二叉堆。</li>
<li>堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。</li>
<li>由于堆的这个特性，常用来实现优先队列，堆的存取是随意</li>
</ol>
<p>这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，我们只需要关心书的名字。</p>
<h1 id="变量类型与内存的关系"><a href="#变量类型与内存的关系" class="headerlink" title="变量类型与内存的关系"></a>变量类型与内存的关系</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型共有6种：</p>
<ol>
<li>Sting</li>
<li>Number</li>
<li>Boolean</li>
<li>null</li>
<li>undefined</li>
<li>Symbol</li>
</ol>
<blockquote>
<p>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。</p>
</blockquote>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ol>
<li>Array</li>
<li>Function</li>
<li>Object</li>
</ol>
<blockquote>
<p>引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
</blockquote>
<h2 id="栈内存和堆内存的优缺点"><a href="#栈内存和堆内存的优缺点" class="headerlink" title="栈内存和堆内存的优缺点"></a>栈内存和堆内存的优缺点</h2><ul>
<li>在JS中，基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。</li>
<li>引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。</li>
<li>栈内存由于它的特点，所以它的系统效率较高。</li>
<li>堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。</li>
</ul>
<h2 id="栈内存和堆内存的垃圾回收"><a href="#栈内存和堆内存的垃圾回收" class="headerlink" title="栈内存和堆内存的垃圾回收"></a>栈内存和堆内存的垃圾回收</h2><p>栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。</p>
<h2 id="闭包与堆内存"><a href="#闭包与堆内存" class="headerlink" title="闭包与堆内存"></a>闭包与堆内存</h2><p>闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量。举一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">A</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。 现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p>
<h1 id="深克隆和浅克隆"><a href="#深克隆和浅克隆" class="headerlink" title="深克隆和浅克隆"></a>深克隆和浅克隆</h1><ol>
<li>浅拷贝只复制对象的第一层属性。如果对象的属性值是基本数据类型（如String、Number、Boolean等），则直接复制值；如果属性值是引用类型（如Array、Object等），则复制其内存地址，而不是复制实际的值或嵌套的对象。以下都是浅拷贝的实现：</li>
</ol>
<ul>
<li><p>Object.assign()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> origin = &#123; <span class="attr">a</span>: <span class="string">&#x27;原始字符串&#x27;</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, origin);</span><br><span class="line">origin.<span class="property">a</span> = <span class="string">&#x27;改变后的字符串&#x27;</span>;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(origin); <span class="comment">// &#123;a: &#x27;改变后的字符串&#x27;, b: &#123;c: 2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123;a: &#x27;原始字符串&#x27;, b: &#123;c: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>扩展运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> origin = &#123; <span class="attr">a</span>: <span class="string">&#x27;原始字符串&#x27;</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = &#123; ...origin &#125;;</span><br><span class="line">origin.<span class="property">a</span> = <span class="string">&#x27;改变后的字符串&#x27;</span>;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(origin); <span class="comment">// &#123;a: &#x27;改变后的字符串&#x27;, b: &#123;c: 2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123;a: &#x27;原始字符串&#x27;, b: &#123;c: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>slice(数组)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> origin = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> copy = origin.<span class="title function_">slice</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy);</span><br></pre></td></tr></table></figure></li>
<li><p>concat</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> original = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> copy = original.<span class="title function_">concat</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>深拷贝相对于浅拷贝来说，不仅复制了对象本身及其包含的原始类型的值，还复制了所有引用类型的实际值。这意味着，如果你修改拷贝对象中的一个引用类型的值，原始对象中相应的值不会发生变化，因为它们指向了不同的内存地址。深拷贝不仅复制对象的第一层属性，还递归复制所有的嵌套对象。这意味着，无论对象有多少层嵌套，深拷贝都会创建所有层次的副本。因此，原始对象和拷贝对象之间不会相互影响。</li>
</ol>
<ul>
<li><p>JSON.parse(JSON.stringify(object))</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(original));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">NaN</span>))  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 JSON.stringify() 将对象序列化（转换为JSON字符串），然后使用 JSON.parse() 将字符串解析为新的对象。这种方法不能复制函数和循环引用的对象。</p>
</blockquote>
</li>
<li><p>递归拷贝</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> copy;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">    copy = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; obj.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        copy[i] = <span class="title function_">deepCopy</span>(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copy = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123; <span class="comment">// 检查是否是对象自身具有的属性，因为in会包含原型链上的属性，这里只拷贝自身的！</span></span><br><span class="line">                copy[key] = <span class="title function_">deepCopy</span>(obj[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用第三方库：如Lodash的 _.cloneDeep()</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = _.<span class="title function_">cloneDeep</span>(original);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2023/02/16/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><h3 id="何为进程？"><a href="#何为进程？" class="headerlink" title="何为进程？"></a>何为进程？</h3><p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</p>
<img src="http://mdrs.yuanjin.tech/img/202208092057573.png" alt="image-20220809205743532" style="zoom:50%;" />

<p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p>
<h3 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a>何为线程？</h3><p>有了进程后，就可以运行程序的代码了。</p>
<p>运行代码的「人」称之为「线程」。</p>
<p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p>
<p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208092108499.png" alt="image-20220809210859457"></p>
<h3 id="浏览器有哪些进程和线程？"><a href="#浏览器有哪些进程和线程？" class="headerlink" title="浏览器有哪些进程和线程？"></a>浏览器有哪些进程和线程？</h3><p><strong>浏览器是一个多进程多线程的应用程序</strong></p>
<p>浏览器内部工作极其复杂。</p>
<p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208092131410.png" alt="image-20220809213152371"></p>
<blockquote>
<p>可以在浏览器的任务管理器中查看当前的所有进程</p>
</blockquote>
<p>其中，最主要的进程有：</p>
<ol>
<li><p>浏览器进程</p>
<p>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p>
</li>
<li><p>网络进程</p>
<p>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p>
</li>
<li><p><strong>渲染进程</strong>（本节课重点讲解的进程）</p>
<p>渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行 HTML、CSS、JS 代码。</p>
<p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p>
<blockquote>
<p>将来该默认模式可能会有所改变，有兴趣的同学可参见<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability">chrome官方说明文档</a></p>
</blockquote>
</li>
</ol>
<h2 id="渲染主线程是如何工作的？"><a href="#渲染主线程是如何工作的？" class="headerlink" title="渲染主线程是如何工作的？"></a>渲染主线程是如何工作的？</h2><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p>
<ul>
<li>解析 HTML</li>
<li>解析 CSS</li>
<li>计算样式</li>
<li>布局</li>
<li>处理图层</li>
<li>每秒把页面画 60 次</li>
<li>执行全局 JS 代码</li>
<li>执行事件处理函数</li>
<li>执行计时器的回调函数</li>
<li>……</li>
</ul>
<blockquote>
<p>思考题：为什么渲染进程不适用多个线程来处理这些事情？</p>
</blockquote>
<p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p>
<p>比如：</p>
<ul>
<li>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？</li>
<li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？</li>
<li>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？</li>
<li>……</li>
</ul>
<p>渲染主线程想出了一个绝妙的主意来处理这个问题：排队</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208092230847.png" alt="image-20220809223027806"></p>
<ol>
<li>在最开始的时候，渲染主线程会进入一个无限循环</li>
<li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</li>
<li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li>
</ol>
<p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p>
<p><strong>整个过程，被称之为事件循环（消息循环）</strong></p>
<h2 id="若干解释"><a href="#若干解释" class="headerlink" title="若干解释"></a>若干解释</h2><h3 id="何为异步？"><a href="#何为异步？" class="headerlink" title="何为异步？"></a>何为异步？</h3><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p>
<ul>
<li>计时完成后需要执行的任务 —— <code>setTimeout</code>、<code>setInterval</code></li>
<li>网络通信完成后需要执行的任务 – <code>XHR</code>、<code>Fetch</code></li>
<li>用户操作后需要执行的任务 – <code>addEventListener</code></li>
</ul>
<p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208101043348.png" alt="image-20220810104344296"></p>
<p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong></p>
<p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p>
<p><img src="http://mdrs.yuanjin.tech/img/202208101048899.png" alt="image-20220810104858857"></p>
<p>使用异步的方式，<strong>渲染主线程永不阻塞</strong></p>
<blockquote>
<p>面试题：如何理解 JS 的异步？</p>
<p>参考答案：</p>
<p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p>
<p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p>
<p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p>
<p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p>
<p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>
</blockquote>
<h3 id="JS为何会阻碍渲染？"><a href="#JS为何会阻碍渲染？" class="headerlink" title="JS为何会阻碍渲染？"></a>JS为何会阻碍渲染？</h3><p>先看代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Mr.Yuan is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> h1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 死循环指定的时间</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">duration</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - start &lt; duration) &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    h1.<span class="property">textContent</span> = <span class="string">&#x27;袁老师很帅！&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">delay</span>(<span class="number">3000</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击按钮后，会发生什么呢？</p>
<p>&lt;见具体演示&gt;</p>
<h3 id="任务有优先级吗？"><a href="#任务有优先级吗？" class="headerlink" title="任务有优先级吗？"></a>任务有优先级吗？</h3><p>任务没有优先级，在消息队列中先进先出</p>
<p>但<strong>消息队列是有优先级的</strong></p>
<p>根据 W3C 的最新解释:</p>
<ul>
<li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li>
<li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></li>
</ul>
<blockquote>
<p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p>
</blockquote>
<p>在目前 chrome 的实现中，至少包含了下面的队列：</p>
<ul>
<li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li>
<li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li>
<li>微队列：用户存放需要最快执行的任务，优先级「最高」</li>
</ul>
<blockquote>
<p>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即把一个函数添加到微队列</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(函数)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑</p>
</blockquote>
<blockquote>
<p>面试题：阐述一下 JS 的事件循环</p>
<p>参考答案：</p>
<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p>
<p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p>
<p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>
<p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p>
</blockquote>
<blockquote>
<p>面试题：JS 中的计时器能做到精确计时吗？为什么？</p>
<p>参考答案：</p>
<p>不行，因为：</p>
<ol>
<li>计算机硬件没有原子钟，无法做到精确计时</li>
<li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li>
<li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li>
</ol>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>你不知道的 CSS 之包含块</title>
    <url>/2024/02/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20CSS%20%E4%B9%8B%E5%8C%85%E5%90%AB%E5%9D%97/</url>
    <content><![CDATA[<p>一说到 <code>CSS</code> 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。</p>
<p>但是一说到 <code>CSS</code> 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142005.png" alt="image-20220814222004395" style="zoom: 20%;" />

<p>好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png" alt="image-20220813140434032" style="zoom:50%;" />

<p>包含块英语全称为 <code>containing block</code>，实际上平时你在书写 CSS 时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的：</p>
<p><em><a href="https://drafts.csswg.org/css2/#containing-block-details">https://drafts.csswg.org/css2/#containing-block-details</a></em></p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142459.png" alt="image-20220814222458695" style="zoom:50%;" />

<p>并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。</p>
<p>那么，这个包含块究竟说了什么内容呢？</p>
<p>说起来也简单，<strong>就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 <code> position</code> 被设置为 <code>absolute</code> 或 <code>fixed</code>），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</strong></p>
<p>来吧，少年，让我们从最简单的 case 开始看。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143153.png" alt="image-20220814223152726" style="zoom: 50%;" />

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143451.png" alt="image-20220814223451349" style="zoom: 33%;" />

<p>相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。</p>
<p>这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 <code>div.container</code> 的 <code>width</code> 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。</p>
<p>这个答案实际上是不准确的。正确的答案应该是，**<code>div.item</code> 的宽高是根据它的包含块来计算的**，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。</p>
<p>因此正如我前面所说，<strong>很多时候你都感受不到包含块的存在。</strong></p>
<p>包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</p>
<p>另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：</p>
<ul>
<li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。</li>
<li>如果 position 属性是 fixed，那么包含块由视口建立。</li>
<li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li>
</ul>
<p>前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。</p>
<p>公布正确答案：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-153548.png" alt="image-20220814233548188" style="zoom: 33%;" />

<p>怎么样？有没有和你所想象的对上？</p>
<p>其实原因也非常简单，根据上面的第三条规则，对于 <code>div.item2</code> 来讲，它的包含块应该是 <code>div.container</code>，而非 <code>div.item</code>。</p>
<p>如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。<br>实际上对于非根元素来讲，包含块还有一种可能，那就是如果 <code>position</code> 属性是 <code>absolute</code> 或 <code>fixed</code>，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：</p>
<ul>
<li><code>transform</code> 或 <code>perspective</code> 的值不是 <code>none</code></li>
<li><code>will-change</code> 的值是 <code>transform</code> 或 <code>perspective</code> </li>
<li><code>filter</code> 的值不是 <code>none</code> 或 <code>will-change</code> 的值是 <code>filter</code>(只在 <code>Firefox</code> 下生效). </li>
<li><code>contain</code> 的值是 <code>paint</code> (例如: contain: paint;)</li>
</ul>
<p>我们还是来看一个示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>); <span class="comment">/* 新增代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对于上面的代码只新增了一条声明，那就是<code> transform: rotate(0deg)</code>，此时的渲染效果却发生了改变，如下图所示：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154347.png" alt="image-20220814234347149" style="zoom:33%;" />

<p>可以看到，此时对于 <code>div.item2</code> 来讲，包含块就变成了<code> div.item</code>。</p>
<p>好了，到这里，关于包含块的知识就基本讲完了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png" alt="image-20220814234654914" style="zoom:33%;" />

<p>我们再把 CSS 规范中所举的例子来看一下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Illustration of containing blocks<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>This is text in the first paragraph...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span></span><br><span class="line">        This is text</span><br><span class="line">        <span class="tag">&lt;<span class="name">em</span> <span class="attr">id</span>=<span class="string">&quot;em1&quot;</span>&gt;</span></span><br><span class="line">          in the</span><br><span class="line">          <span class="tag">&lt;<span class="name">strong</span> <span class="attr">id</span>=<span class="string">&quot;strong1&quot;</span>&gt;</span>second<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">          paragraph.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面是一段简单的 <code>HTML</code> 代码，在没有添加任何 <code>CSS</code> 代码的情况下，你能说出各自的包含块么？</p>
<p>对应的结果如下：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>body</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>p2</td>
</tr>
<tr>
<td>strong1</td>
<td>p2</td>
</tr>
</tbody></table>
<p>首先 <code>HTML</code> 作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body 而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为 <code>html</code>，以此类推 <code>div1、p1、p2</code> 以及 <code>em1</code> 的包含块也都是它们的父元素。</p>
<p>不过 <code>strong1</code> 比较例外，它的包含块确实 <code>p2</code>，而非 <code>em1</code>。为什么会这样？建议你再把非根元素的第一条规则读一下：</p>
<ul>
<li>如果元素的 <code>positiion</code> 是 <code>relative</code> 或 <code>static</code> ，那么包含块由离它最近的<strong>块容器（block container）</strong>的内容区域（content area）的边缘建立。</li>
</ul>
<p>没错，因为 <code>em1</code> 不是块容器，而包含块是<strong>离它最近的块容器</strong>的内容区域，所以是 <code>p2</code>。</p>
<p>接下来添加如下的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#div1</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50px</span>; <span class="attribute">top</span>: <span class="number">50px</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码我们对 <code>div1</code> 进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。</p>
<p>答案如下：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>p2</td>
</tr>
<tr>
<td>strong1</td>
<td>p2</td>
</tr>
</tbody></table>
<p>可以看到，这里 <code>div1</code> 的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话：</p>
<ul>
<li>初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</li>
<li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li>
</ul>
<p>是不是一下子就理解了。没错，因为我们对 div1 进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的  <code>position</code> 的值不是 <code>static</code> 的祖先元素，不过显然 <code>body</code> 的定位方式为 <code>static</code>，因此 div1 的包含块最终就变成了初始包含块。</p>
<p>接下来我们继续修改我们的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#div1</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50px</span>; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#em1</span>  &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们对 <code>em1</code> 同样进行了 <code>absolute</code> 绝对定位，你想一想会有什么样的变化？</p>
<p>没错，聪明的你大概应该知道，<code>em1</code> 的包含块不再是 <code>p2</code>，而变成了 <code>div1</code>，而 <code>strong1</code> 的包含块也不再是 <code>p2</code> 了，而是变成了 <code>em1</code>。</p>
<p>如下表所示：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>div1（因为定位了，参阅非根元素包含块确定规则的第三条）</td>
</tr>
<tr>
<td>strong1</td>
<td>em1（因为 em1 变为了块容器，参阅非根元素包含块确定规则的第一条）</td>
</tr>
</tbody></table>
<p>好了，这就是 <code>CSS</code> 规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的 <code>CSS</code> 规范的人。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-013519.png" alt="image-20220815093518833" style="zoom:33%;" />

<p>另外，关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。</p>
<p>具体你可以移步到：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block</a></em></p>
<p>好了，这就是有关包含块的所有内容了，你学会了么？-）</p>
<hr>
<p>-<em>EOF</em>-</p>
]]></content>
  </entry>
  <entry>
    <title>深入理解防抖和节流</title>
    <url>/2024/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>防抖</code>和<code>节流</code>是前端开发中常用的函数优化手段，它们可以限制函数的执行频率，提升性能和用户体验。主要用于处理高频触发的事件，例如：用户的滚动、输入、点击和表单的重复提交等。</p>
<h1 id="防抖与节流的区别"><a href="#防抖与节流的区别" class="headerlink" title="防抖与节流的区别"></a>防抖与节流的区别</h1><p>先简单描述下它们的作用</p>
<ul>
<li><p>防抖：如果一个函数持续地、频繁地触发，那么只在它结束后过一段时间才开始执行。换句话说，如果你持续触发事件，那么防抖函数将不会执行，只有当你停止触发事件后，它才会在指定的延迟时间后执行。这对于防止例如用户在输入框中连续输入时发送过多的Ajax请求等情况非常有用。</p>
</li>
<li><p>节流：如果你持续触发事件，每隔一段时间，事件处理函数只执行一次。这有助于限制一些处理函数的执行频率，例如：滚动事件、窗口大小调整事件等。</p>
</li>
</ul>
<p>简而言之，防抖是在事件停止触发后延迟执行函数，而节流是按照固定的时间间隔执行函数。</p>
<p>因为<code>防抖</code>和<code>节流</code>的作用和应用场景基本相同，也就导致它们容易被混淆。</p>
<h2 id="防抖的实现与使用"><a href="#防抖的实现与使用" class="headerlink" title="防抖的实现与使用"></a><strong>防抖的实现与使用</strong></h2><p>防抖的应用场景：</p>
<ol>
<li>输入框搜索：当用户在搜索框中输入关键字时，使用防抖可以避免频繁发送搜索请求，而是在用户停止输入一段时间后才发送请求，减轻服务器压力。</li>
<li>按钮点击：当用户点击按钮时，使用防抖可以避免用户多次点击造成的多次提交或重复操作。</li>
</ol>
<p>实现防抖的基本方式是利用定时器，每次触发事件时都清除上一次的定时器，然后重新设置一个新的定时器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 防抖函数  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> timeout;  </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> context = <span class="variable language_">this</span>;  </span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">clearTimeout</span>(timeout);  </span></span><br><span class="line"><span class="language-javascript">                timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> func.<span class="title function_">apply</span>(context, args), wait);  </span></span><br><span class="line"><span class="language-javascript">            &#125;;  </span></span><br><span class="line"><span class="language-javascript">        &#125;  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用防抖函数控制连续触发事件的处理函数执行频率  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> debouncedHandler = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Debounced event triggered&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">500</span>);  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,debouncedHandler)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="节流的实现与使用"><a href="#节流的实现与使用" class="headerlink" title="节流的实现与使用"></a>节流的实现与使用</h1><p>节流的应用场景：</p>
<ol>
<li>页面滚动：当页面滚动时，使用节流可以限制滚动事件的触发频率，减少事件处理的次数，提高页面的响应性能。</li>
<li>按钮点击：当用户点击按钮时，使用节流可以减少事件处理的次数，避免过于频繁的操作。</li>
</ol>
<p>实现节流的方式也是利用定时器，但与防抖不同的是，节流会保证在一个固定的时间间隔内至少执行一次事件处理函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       </span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 节流函数  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, limit</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> inThrottle;  </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> context = <span class="variable language_">this</span>;  </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (!inThrottle) &#123;  </span></span><br><span class="line"><span class="language-javascript">                func.<span class="title function_">apply</span>(context, args);  </span></span><br><span class="line"><span class="language-javascript">                inThrottle = <span class="literal">true</span>;  </span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> inThrottle = <span class="literal">false</span>, limit);  </span></span><br><span class="line"><span class="language-javascript">                &#125;  </span></span><br><span class="line"><span class="language-javascript">            &#125;;  </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用节流函数控制连续触发事件的处理函数执行频率  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> throttledHandler = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Throttled event triggered&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,throttledHandler)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在实际的前端开发中，防抖和节流的使用场景非常广泛。例如：搜索框的实时搜索建议可以使用防抖来减少服务器请求；滚动加载更多数据可以使用节流来防止在短时间内发送过多的请求。通过使用这两种技术，我们可以有效地优化前端的性能，提升用户体验。</p>
<p>本文转自 <a href="https://juejin.cn/post/7324522555268366351?searchId=202403011646443E84D49F22E455869CE8">https://juejin.cn/post/7324522555268366351?searchId=202403011646443E84D49F22E455869CE8</a>，如有侵权，请联系删除。</p>
]]></content>
  </entry>
  <entry>
    <title>如何区别进程和线程、协程的关系</title>
    <url>/2024/02/29/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%AB%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
</blockquote>
<ul>
<li>狭义定义：进程就是一段程序的执行过程例如启动的某个app。</li>
<li>广义定义：进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它是<code>操作系统动态执行的基本单元</code>，在传统的操作系统中,进程即是基本的分配单元，也是基本的执行单元。</li>
</ul>
<p><code>1.进程(process)最小的资源管理单元[操作系统] 2.应用程序的启动实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间</code></p>
<p>进程的生命周期基本由操作系统内核进行支配，即进程的创建、切换、销毁等操作都将使会陷入内核，进行系统调用。该操作消耗较大。当进行进程的销毁时，包含但不仅于内存地址空间、内核态堆栈和硬件上下文(CPU寄存器)的切换甚至在内存资源较少的情况下会将已存入内存的数据写入磁盘交换区，代价较大。因此，我们可以发现当系统运行的进程越多，系统越是卡顿。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>每个进程都有自己的地址空间，一般情况下，包含文本区域、数据区域、堆栈</li>
<li>进程是执行中的程序，程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称之为进程</li>
<li>进程本身不会运行，是线程的容器。线程不能单独执行，必须组成进程</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>对于操作系统来讲，一个任务就是一个进程，比如开一个浏览器就是启动一个浏览器进程。打开一款app就是打开一个进程。</li>
<li>有些进程还不止同时做一件事情。在一个进程内部，可以同时做多件事情，比如边看视频可以边发弹幕。</li>
</ul>
<h3 id="进程状态：（三状态）"><a href="#进程状态：（三状态）" class="headerlink" title="进程状态：（三状态）"></a>进程状态：（三状态）</h3><ul>
<li>就绪：获取CPU外的所有资源、只要处理器分配资源就可以马上执行</li>
<li>运行：获得处理器分配的资源，程序开始执行</li>
<li>阻塞：当程序条件不够的时候，需要等待提交满足的时候才能执行。</li>
</ul>
<h3 id="状态详解"><a href="#状态详解" class="headerlink" title="状态详解"></a>状态详解</h3><ul>
<li>创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，<code>完成资源分配</code>。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</li>
<li>就绪状态：进程已经准备好，<code>已分配到所需资源，只要分配到CPU就能够立即运行</code></li>
<li>执行状态：进程<code>处于就绪状态被调度后，进程进入执行状态</code></li>
<li>阻塞状态：正在执行的进程由于某些事件（I&#x2F;O请求，申请缓存区失败）而暂时无法运行，<code>进程受到阻塞</code>。在满足请求时进入就绪状态等待系统调用</li>
<li>终止状态：<code>进程结束，或出现错误，或被系统终止</code>，进入终止状态。无法再执行</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
</blockquote>
<p><code>1.线程(thread)最小的执行单元[操作系统] 2.一个进程包含多个线程(一主多从),拥有自己的栈空间</code></p>
<h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ul>
<li>一个进程中至少有一个线程，不然就没有存在的意义</li>
<li>在一个进程内部，要同时干多件事情，就需要同时运行多个子任务，我们把进程内的这些子任务叫做线程</li>
<li>多线程就是为了同步完成多项任务(在单个程序中同时运行多个线程完成不同的任务和工作)，是为了提高资源使用效率来提高系统的效率，而不是为了提高运行效率。</li>
<li>一个简单的比喻，多线程就像是给车保养的工人有洗车工有维修有美容的，而进程就是待被清洗维护美容店车</li>
<li>线程是程序执行流的最小单元。一个标准的线程由当前的线程ID、当前指令指针、寄存器和堆栈组成</li>
<li>同一个进程中的多个线程之间可以并发执行</li>
</ul>
<h3 id="线程状态："><a href="#线程状态：" class="headerlink" title="线程状态："></a>线程状态：</h3><ul>
<li>就绪：指线程具备运行的所有条件，逻辑上可以运行，在等待处理机</li>
<li>运行：指线程占用处理机正在运行</li>
<li>阻塞：线程在等待一个事件，逻辑上不可执行</li>
</ul>
<h3 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h3><ul>
<li><p>进程是操作系统资源分配的<code>基本单位</code>，而线程是任务调度和执行的基本单位</p>
<p>线程和进程的实现在操作系统之间有所不同，但在大多数情况下，线程是进程的一个组件。进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。在操作系统中能同时运行多个进程；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。</p>
</li>
<li><p>进程拥有独立的<code>内存空间</code>，线程则共享所在进程中的内存空间</p>
<p>进程是系统中独立存在的实体，它可以拥有自己独立的资源，系统在运行的时候会为每个进程分配不同的内存空间，所以每一个进程都拥有自己私有的内存空间。在没有经过进程本身允许的情况下，一个用户的进程不可以直接访问其它进程的内存空间。而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），一个进程中的多个线程之间只能共享进程的资源。而不同的进程不共享这些资源。</p>
</li>
<li><p>进程之间切换开销较大，而线程间切换<code>开销</code>较小</p>
<p>每个进程都有独立的数据空间（程序上下文），进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程的切换的消耗随略小于进程，较少进行内存和磁盘的交换，但是仍然会有堆栈的映射和切换。</p>
</li>
<li><p>程序是一个静态<code>指令的集合</code>，而进程是一个正在系统中活动的指令集合</p>
<p>进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态，这写概念在程序中是不具备的。</p>
</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的<strong>轻量级线程</strong>，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。</p>
<p><code>1.协程(Coroutines)特殊的函数[程序控制] 2.一个线程可以拥有多个协程 3.可以暂停执行（暂停的表达式称为暂停点) 4.可以从挂起点恢复（保留其原始参数和局部变量） 5.事件循环是异步编程的底层基石</code></p>
<p>从名字可以看出，协程的粒度比线程更小，并且是用户管理和控制的，多个协程可以运行在一个线程上面。那么协程出现的背景又是什么呢，先来看一下目前线程中影响性能的特性：</p>
<ul>
<li>使用锁机制</li>
<li>线程间的上下文切换</li>
<li>线程运行和阻塞状态的切换</li>
</ul>
<p>以上任意一点都是很消耗cpu性能的。相对来说协程是由程序自身控制，没有线程切换的开销，且不需要锁机制，因为在同一个线程中运行，不存在同时写变量冲突，在协程中操作共享资源不加锁，只需要判断状态就行了，所以执行效率比线程高的多。</p>
<h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p>
<ul>
<li><p>对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p>
</li>
<li><p>对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）</p>
</li>
</ul>
<h3 id="协程的优点："><a href="#协程的优点：" class="headerlink" title="协程的优点："></a>协程的优点：</h3><ol>
<li>无需线程上下文切换的开销，goroutine(协程) 切换调度开销方面远比线程小。</li>
<li>无需原子操作锁定及同步的开销</li>
<li>方便切换控制流，简化编程模型</li>
<li>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。goroutine：2KB（官方），线程：8MB（参考网络）</li>
</ol>
<p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p>
<h3 id="协程的缺点："><a href="#协程的缺点：" class="headerlink" title="协程的缺点："></a>协程的缺点：</h3><ol>
<li>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li>
<li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</li>
</ol>
<p><strong>CPU密集型代码(各种循环处理、计算等等)：使用多进程。IO密集型代码(文件处理、网络爬虫等)：使用多线程</strong></p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><strong>并发与并行</strong></h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。</p>
<p>当有多个线程时，如果系统只有一个CPU，那么CPU不可能真正同时进行多个线程，CPU的运行时间会被划分成若干个时间段，每个时间段分配给各个线程去执行，一个时间段里某个线程运行时，其他线程处于挂起状态，这就是并发。并发解决了程序排队等待的问题，如果一个程序发生阻塞，其他程序仍然可以正常执行。</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。</p>
<h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ol>
<li>并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。</li>
<li>在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。</li>
</ol>
<p>知乎上高赞例子：</p>
<ul>
<li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li>
<li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li>
<li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li>
</ul>
<p>并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是 <strong>『同时』</strong>。</p>
<h2 id="JavaScript中的协程"><a href="#JavaScript中的协程" class="headerlink" title="JavaScript中的协程"></a>JavaScript中的协程</h2><h3 id="JavaScript-协程的发展"><a href="#JavaScript-协程的发展" class="headerlink" title="JavaScript 协程的发展"></a>JavaScript 协程的发展</h3><ul>
<li>同步代码</li>
<li>异步JavaScript: callback hell（回调地狱）</li>
<li>ES6引入 Promise&#x2F;a+, 生成器Generators(语法 _<em>function</em> foo(){}_*  可以赋予函数执行暂停&#x2F;保存上下文&#x2F;恢复执行状态的功能), 新关键词yield使生成器函数暂停.</li>
<li>ES7引入 async函数&#x2F;await语法糖,async可以声明一个异步函数(将Generator函数和自动执行器，包装在一个函数里)，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果,</li>
</ul>
<p>Promise中也利用了回调函数。在then和catch方法中都传入了一个回调函数，分别在Promise被满足和被拒绝时执行, 这样就就能让它能够被链接起来完成一系列任务。总之就是把层层嵌套的 callback 变成 .then().then()…，从而使代码编写和阅读更直观</p>
<p>生成器Generator的底层实现机制是协程Coroutine。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo start&quot;</span>)     a = <span class="keyword">yield</span> <span class="number">1</span>;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo a&quot;</span>, a)     <span class="keyword">yield</span> <span class="number">2</span>;     <span class="keyword">yield</span> <span class="number">3</span>;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo end&quot;</span>) &#125; <span class="keyword">const</span> gen = <span class="title function_">foo</span>(); <span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1 // gen.send(&quot;a&quot;) // http://www.voidcn.com/article/p-syzbwqht-bvv.html SpiderMonkey引擎支持 send 语法 console.log(gen.next().value); // 2 console.log(gen.next().value); // 3 console.log(foo().next().value); // 1 console.log(foo().next().value); // 1 /* foo start 1 foo a undefined 2 3 foo start 1 foo start 1 */</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-协程成熟体"><a href="#JavaScript-协程成熟体" class="headerlink" title="JavaScript 协程成熟体"></a>JavaScript 协程成熟体</h3><h4 id="Promise继续使用"><a href="#Promise继续使用" class="headerlink" title="Promise继续使用"></a>Promise继续使用</h4><p>Promise 本质是一个状态机，用于表示一个异步操作的最终完成 (或失败), 及其结果值。它有三个状态：</p>
<ul>
<li>pending: 初始状态，既不是成功，也不是失败状态。</li>
<li>fulfilled: 意味着操作成功完成。</li>
<li>rejected: 意味着操作失败。</li>
</ul>
<p>最终 Promise 会有两种状态，一种成功，一种失败，当 pending 变化的时候，Promise 对象会根据最终的状态调用不同的处理函数。</p>
<h4 id="async、await语法糖"><a href="#async、await语法糖" class="headerlink" title="async、await语法糖"></a>async、await语法糖</h4><p>async、await 是对 Generator 和 Promise 组合的封装, 使原先的异步代码在形式上更接近同步代码的写法,并且对错误处理&#x2F;条件分支&#x2F;异常堆栈&#x2F;调试等操作更友好。Async、Await 实现了 Generator 的自动迭代，正因为 Async、Await 是对 Generator 和 Promise 组合的封装，所以 Async 和 Await 基本上就只能用来实现异步和并发了，而不具有协程的其他作用。</p>
<h3 id="JavaScript-异步执行的运行机制"><a href="#JavaScript-异步执行的运行机制" class="headerlink" title="JavaScript 异步执行的运行机制"></a>JavaScript 异步执行的运行机制</h3><ol>
<li>所有任务都在主线程上执行，形成一个执行栈。\</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。\</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。</li>
</ol>
<p>遇到同步任务直接执行,遇到异步任务分类为宏任务(macro-task)和微任务(micro-task)。<br>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sleep = <span class="keyword">function</span> (<span class="params">time</span>) &#123;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sleep start&quot;</span>)     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;         <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;             <span class="title function_">resolve</span>();         &#125;, time);     &#125;); &#125;; <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">exec</span>(<span class="params"></span>) &#123;     <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">2000</span>);     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sleep end&quot;</span>) &#125; <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params"></span>) &#123;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>())     c1 = <span class="title function_">exec</span>()     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------1&quot;</span>)     c2 = <span class="title function_">exec</span>()     <span class="variable language_">console</span>.<span class="title function_">log</span>(c1, c2)     <span class="keyword">await</span> c1;     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------2&quot;</span>)     <span class="keyword">await</span> c2;     <span class="variable language_">console</span>.<span class="title function_">log</span>(c1, c2)     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>()) &#125; <span class="title function_">go</span>();</span><br></pre></td></tr></table></figure>

<h3 id="event-loop将任务划分："><a href="#event-loop将任务划分：" class="headerlink" title="event loop将任务划分："></a>event loop将任务划分：</h3><ul>
<li>主线程循环从”任务队列”中读取事件</li>
<li>宏队列（macro task）js同步执行的代码块，setTimeout、setInterval、XMLHttprequest、setImmediate、I&#x2F;O、UI rendering等, 本质是参与了事件循环的任务.</li>
<li>微队列（micro task）Promise、process.nextTick（node环境）、Object.observe, MutationObserver等,本质是直接在 Javascript 引擎中的执行的没有参与事件循环的任务.</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h2><ol>
<li>线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。</li>
<li>对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。</li>
<li>所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</li>
</ol>
<p>总结：进程、线程和协程的设计，都是为了并发任务能够更好的利用CPU资源，他们最大的区别即在于对CPU的使用上(任务调度)：如前文所述，进程和线程的任务调度由内核控制，是抢占式的；而协程的任务调度在用户态完成，需要在代码里显式的把CPU交给其他协程，是协作式的。</p>
<p>由于我们可以在用户态调度协程任务，所以，我们可以把一组互相依赖的任务设计成协程。这样，当一个协程任务完成之后，可以手动进行任务调度，把自己挂起(yield)，切换到另外一个协程执行。这样，由于我们可以控制程序主动让出资源，很多情况下将不需要对资源加锁。</p>
]]></content>
  </entry>
  <entry>
    <title>神经网络入门</title>
    <url>/2024/03/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="何为张量？"><a href="#何为张量？" class="headerlink" title="何为张量？"></a>何为张量？</h1><blockquote>
<p>仅包含一个数字的张量叫做标量（<code>scalar</code>也叫标量, 零维张量,<strong>0D张量</strong>）。<br>在<code>Numpy</code>中，一个<code>float32</code>或者<code>float64</code>的数字就是一个标量张量（或者标量数组）。你可以用<code>ndim</code>属性<br>来查看张量的轴数.</p>
</blockquote>
<h2 id="0D张量（标量）"><a href="#0D张量（标量）" class="headerlink" title="0D张量（标量）"></a>0D张量（标量）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">np.array(12)</span><br></pre></td></tr></table></figure>
<h2 id="1D张量（向量）"><a href="#1D张量（向量）" class="headerlink" title="1D张量（向量）"></a>1D张量（向量）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure>
<h2 id="2D张量（矩阵）"><a href="#2D张量（矩阵）" class="headerlink" title="2D张量（矩阵）"></a>2D张量（矩阵）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表示3x5长度的矩阵</span></span><br><span class="line">np.array([[<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">79</span>,<span class="number">3</span>,<span class="number">35</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="3D张量和更高维的张量"><a href="#3D张量和更高维的张量" class="headerlink" title="3D张量和更高维的张量"></a>3D张量和更高维的张量</h2><ul>
<li>5D向量–表示一个轴有五个数值</li>
<li>5D张量–表示有五个轴<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([</span><br><span class="line">        [[<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">79</span>,<span class="number">3</span>,<span class="number">35</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">2</span>]],</span><br><span class="line">        [[<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">79</span>,<span class="number">3</span>,<span class="number">35</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">2</span>]],</span><br><span class="line">        [[<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">79</span>,<span class="number">3</span>,<span class="number">35</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="number">36</span>,<span class="number">2</span>]]</span><br><span class="line">      ])</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="张量的关键属性"><a href="#张量的关键属性" class="headerlink" title="张量的关键属性"></a>张量的关键属性</h2><ul>
<li>ndim（轴的个数）</li>
<li>形状 &#x3D;&gt; 3D形状(3,3,5)&#x3D;&gt;表示3个3x5的矩阵</li>
<li>数据类型–<code>float32</code>(例如：MINIST的数据集为由8位整数组成的3D张量,每个矩阵都表示为灰度图像)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###从train_image数据集中抽（90,28,28）的图像</span></span><br><span class="line">train_image[<span class="number">10</span>:<span class="number">100</span>]==train_image[<span class="number">10</span>:<span class="number">100</span>,:,:]==train_image[<span class="number">10</span>:<span class="number">100</span>,<span class="number">0</span>:<span class="number">28</span>,<span class="number">0</span>:<span class="number">28</span>]</span><br><span class="line"><span class="comment">####截取所有图片14x14的图像</span></span><br><span class="line">train_image[:,<span class="number">14</span>:,<span class="number">14</span>:]</span><br><span class="line"><span class="comment">####截取所有图片中心截取14x14的图像</span></span><br><span class="line">train_image[:,<span class="number">7</span>:-<span class="number">7</span>,<span class="number">7</span>:-<span class="number">7</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="现实中物体如何用张量表示"><a href="#现实中物体如何用张量表示" class="headerlink" title="现实中物体如何用张量表示"></a>现实中物体如何用张量表示</h2><ul>
<li>向量数据：2D–形状(samples,features)</li>
<li>时间序列或序列数据：3D张量, (samples,timesteps,features)</li>
<li>图像：4D –(samples,height,width,channels)</li>
<li>视频:5D –(samples,frames,height,width,channels)</li>
</ul>
<h2 id="训练模型用到哪些数据集"><a href="#训练模型用到哪些数据集" class="headerlink" title="训练模型用到哪些数据集"></a>训练模型用到哪些数据集</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ol>
<li>非张量数据类型需要做数据转换，实际操作例如<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mean=train_data.mean(axis=<span class="number">0</span>)</span><br><span class="line">train_data-=mean</span><br><span class="line">std=train_data.std(axis=<span class="number">0</span>)</span><br><span class="line">train_data/ =std</span><br><span class="line"></span><br><span class="line">test_data-=mean</span><br><span class="line">test_data/=std</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h3><ol>
<li>训练集留出验证集来防止信息泄露<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_validation_samples=<span class="number">10000</span></span><br><span class="line"><span class="comment">##需要打乱数据</span></span><br><span class="line">np.random.suffle(data)</span><br><span class="line"><span class="comment">##定义验证集</span></span><br><span class="line">validatation_data=data[:numvalidation_samples]</span><br><span class="line">data=data[num_validation_samples:]</span><br><span class="line">   <span class="comment">##定义训练集</span></span><br><span class="line"> training_data=data[:]</span><br><span class="line"> 训练集训练模型</span><br><span class="line"> 验证集评估模型</span><br><span class="line"> model=get_model()</span><br><span class="line"> model.train(training_data)</span><br><span class="line"> validation_score=model.evaluate(validation_data)</span><br><span class="line"> <span class="comment">#现在你可以调节模型、重新训练、评估，然后再次调节....</span></span><br><span class="line"> model=get_model()                   					   			model.train(np.concatence([training_data,validation_data]))</span><br><span class="line">  test_score=model.evaluate(test_data)</span><br><span class="line"> <span class="comment">###一旦调节号超参数，通常就在所有非测试数据上从头开始训练最终模型</span></span><br></pre></td></tr></table></figure></li>
<li>训练过程超参数调优<ul>
<li>使用tensorBoard和keras可视化训练过程</li>
<li>使用批量和小批量工作 –早停方法防止过拟合</li>
<li>使用网格搜索调整参数 –Hyperopt</li>
<li>学习率和学习率调度</li>
<li>比较优化器</li>
<li>确定网络的深度</li>
<li>添加Dropout以防止过拟合</li>
<li>通过数据增广使模型更好</li>
<li>利用TTA来提高精度</li>
</ul>
</li>
<li>利用keras框架中的tensorBoard<code>callbacks=[EarlyStopping()]回调函数</code></li>
<li>分析网络内部结构<ul>
<li>用tensorBoard可视化训练结构</li>
<li>用tensorBoard可视化网络结构</li>
<li>分析网络权重</li>
<li>冻结层</li>
<li>存储网络结构并训练权重</li>
</ul>
</li>
</ol>
<h3 id="验证集"><a href="#验证集" class="headerlink" title="验证集"></a>验证集</h3><ol>
<li>通过K折验证算法打乱验证集<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k=<span class="number">4</span></span><br><span class="line">num_validation_samples=<span class="built_in">len</span>(data) //k</span><br><span class="line">np.random.shuffle(data)</span><br><span class="line">validation_scores=[]</span><br><span class="line"><span class="keyword">for</span> fold <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line"><span class="comment">###选择验证集区域</span></span><br><span class="line">    validation_data=data[num_validaion_samples * fold:</span><br><span class="line">    num_validation_samples*(fold+<span class="number">1</span>)]</span><br><span class="line">    <span class="comment">###使用剩余数据作为训练数据，注意，+运算符是列表合并，不是求和</span></span><br><span class="line">    train_data=data[:num_validation_samples*fold]+data[num_validation_samples*(fold+<span class="number">1</span>):]</span><br><span class="line">    <span class="comment">##创建一个全新的模型</span></span><br><span class="line">    model=get_model()</span><br><span class="line">    model.train(training_data)</span><br><span class="line">    validation_score=model.evaluate(validation_data)</span><br><span class="line">    validation_scores.append(validation_score)</span><br><span class="line">    <span class="comment">##k折取平均值</span></span><br><span class="line">    validation_score=np.average(validation_scores)</span><br><span class="line"> <span class="comment">#在非测试集上训练最终的模型</span></span><br><span class="line"> model=get_model()</span><br><span class="line"> model.train(data)</span><br><span class="line"> test_score=model.evaluate(test_data)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="层"><a href="#层" class="headerlink" title="层"></a>层</h1><blockquote>
<p>包含数据的变换和权重</p>
</blockquote>
<h2 id="如何定义输入层和输出层"><a href="#如何定义输入层和输出层" class="headerlink" title="如何定义输入层和输出层"></a>如何定义输入层和输出层</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">####输出32个密集层</span></span><br><span class="line">model.add(Dense(<span class="number">32</span>,input_shape=<span class="number">784</span>))</span><br><span class="line"><span class="comment">####默认为上一个输出层的输出当作下一层输入</span></span><br><span class="line">model.add(Dense(<span class="number">32</span>))</span><br></pre></td></tr></table></figure>

<h2 id="层在训练过程如何优化"><a href="#层在训练过程如何优化" class="headerlink" title="层在训练过程如何优化"></a>层在训练过程如何优化</h2><p>在训练的过程中需要将损失函数（目标函数）最小化，不同的训练类型有不同的处理</p>
<ol>
<li>二类分类（binary cossentropy）</li>
<li>多分类(categorial cossentropy)</li>
</ol>
<ul>
<li>采用优化器（<code>adm，rmsprop，sgd</code>）提高学习率</li>
</ul>
<ol start="3">
<li>回归问题(mean-squared error)</li>
</ol>
<ul>
<li>采用激活函数将线性转为非线性</li>
</ul>
<ol start="4">
<li>联结主义时序分类(CTC)</li>
<li>其他场景</li>
</ol>
<ul>
<li>将整数数列编码为二进制矩阵</li>
</ul>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vectorize_sequences</span>(<span class="params">sequences,dimension=<span class="number">10000</span></span>):</span><br><span class="line">  <span class="comment">#零矩阵</span></span><br><span class="line">  res=np.zeros((<span class="built_in">len</span>(sequences),dimension))</span><br><span class="line">  <span class="keyword">for</span> i,sequences <span class="keyword">in</span> <span class="built_in">enumerate</span>(sequences)：</span><br><span class="line">   <span class="comment">#res[i]的制定索引设为1</span></span><br><span class="line">   res[i,sequences]=<span class="number">1</span></span><br><span class="line"><span class="comment">###标签向量化</span></span><br><span class="line">np.asarray(train_lables).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>绘制训练损失和验证损失数据分析图防止过拟合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">history_dic=history.history</span><br><span class="line">loss_values=history_dic[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss_values=history_dic[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs=<span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(loss_values)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs,loss_values,<span class="string">&#x27;bo&#x27;</span>,label=<span class="string">&#x27;training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs,loss_values,<span class="string">&#x27;b&#x27;</span>,label=<span class="string">&#x27;val loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;loss&quot;</span>)</span><br><span class="line">plt.xlabes(<span class="string">&quot;epochs&quot;</span>)</span><br><span class="line">plt.xlabes(<span class="string">&quot;loss&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="如何定义卷积的参数"><a href="#如何定义卷积的参数" class="headerlink" title="如何定义卷积的参数"></a>如何定义卷积的参数</h2><ul>
<li><p>从输入中提取的图块尺寸–3x3</p>
</li>
<li><p>输出特征图的深度，例如第一层深度32</p>
</li>
<li><p>输出的高度和宽度可与输入的宽度和高度不同，不同的原因有两点</p>
<ol>
<li>边界效应–可以输入特征图进行填充</li>
<li>输出特征图的空间维度与输入相同–使用填充（padding）</li>
<li>最大池化运算</li>
</ol>
</li>
<li><p>数据预处理</p>
</li>
</ul>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDateGenerator</span><br><span class="line"><span class="comment">###将所以图像乘以1/255缩放</span></span><br><span class="line">train_datagen=ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line">test_datagen=ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line"> train_generator=train_datagen.flow_from_directory(</span><br><span class="line">   train_dir,<span class="comment">##目标目录</span></span><br><span class="line">   target_size=(<span class="number">150</span>,<span class="number">150</span>),<span class="comment">##将所以图像大小调整150x150</span></span><br><span class="line">   batch_size=<span class="number">20</span>,</span><br><span class="line">   class_mode=<span class="string">&#x27;binary&#x27;</span><span class="comment">###因为用到binary_crossentropy</span></span><br><span class="line"> )</span><br><span class="line"> valiation_generator=test_datagen.flow_from_directory(</span><br><span class="line">   train_dir,<span class="comment">##目标目录</span></span><br><span class="line">   target_size=(<span class="number">150</span>,<span class="number">150</span>),<span class="comment">##将所以图像大小调整150x150</span></span><br><span class="line">   batch_size=<span class="number">20</span>,</span><br><span class="line">   class_mode=<span class="string">&#x27;binary&#x27;</span><span class="comment">###因为用到binary_crossentropy</span></span><br><span class="line"> )</span><br><span class="line"> <span class="comment">##python 生成器</span></span><br><span class="line"> history=model.fit_generator(</span><br><span class="line">   train_generator,</span><br><span class="line">   steps_per_epoch=<span class="number">100</span>,</span><br><span class="line">   epochs=<span class="number">30</span>,</span><br><span class="line">   validation_data=validatation_generator,</span><br><span class="line">   validation_steps=<span class="number">50</span></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="如何使用预训练的卷积神经网络"><a href="#如何使用预训练的卷积神经网络" class="headerlink" title="如何使用预训练的卷积神经网络"></a>如何使用预训练的卷积神经网络</h2><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><blockquote>
<p>特征提取就是提取之前训练好的网络的卷积基，在上面运行新的数据，然后再输出的上面训练一个新的分类器</p>
</blockquote>
<ol>
<li>VGG16模型参数详解</li>
</ol>
<ul>
<li>weights：模块初始化检查点</li>
<li>include_top: 是否使用自带的密集器</li>
<li>input_shape: 网络输入图像的形状，可选–处理任意的图像形状</li>
</ul>
<p>例如：使用数据增强的特征提取–建议运行GPU上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">model=model.Sequential()</span><br><span class="line">model.add(conv_base)</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">256</span>,activatiion=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">256</span>,activatiion=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"><span class="comment">##在keras中，冻结网络的方法是将其trainable属性设置为false</span></span><br><span class="line"></span><br><span class="line">conv_base.trainable=false</span><br><span class="line"><span class="comment">##编译使其生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##数据增加</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>微调模型</li>
</ol>
<p>微调是指将其顶部的几层解冻，并将折解冻的几层和新增加的部分联合训练，在已经训练好的基网络上添加自定义网络，冻结基网络，训练所添加的部分，解冻基网络的一些层，联合训练解冻的这些层和添加的部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###冻结直到某一层的所有层</span></span><br><span class="line">conv_base.trainable=true</span><br><span class="line">set_trainable=false</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> conv_base.layers:</span><br><span class="line">    <span class="keyword">if</span> layer.name == <span class="string">&#x27;block5_conv1&#x27;</span>:</span><br><span class="line">       set_trainable=<span class="literal">True</span></span><br><span class="line">     <span class="keyword">if</span> set_trainable:</span><br><span class="line">        layer.trainable=true</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">         layer.trainable=false      </span><br><span class="line"><span class="comment">##微调模型</span></span><br><span class="line">  model.<span class="built_in">compile</span>(</span><br><span class="line">  loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">  optimizer=optimizers.RMSprop(lr=<span class="number">1e-5</span>),</span><br><span class="line">  metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">  history=model.fit_generator(</span><br><span class="line">    train_generator,</span><br><span class="line">    steps_per_epoch=<span class="number">100</span>,</span><br><span class="line">    epochs=<span class="number">100</span>,</span><br><span class="line">    validation_data=validation_generator,</span><br><span class="line">    validation_steps=<span class="number">50</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h2 id="卷积神经网络的可视化"><a href="#卷积神经网络的可视化" class="headerlink" title="卷积神经网络的可视化"></a>卷积神经网络的可视化</h2><ul>
<li>可视化卷积神经网络的中间输出（中间激活）:有助于理解卷积神经网络连续的层如何对输入进行变换，也有助于初步了解卷积网络每个过滤器的含义</li>
<li>可视化卷积神经网络的过滤器：有助于精确理解卷积神经网络中每个过滤器容易接受的视觉模式或视觉概念</li>
<li>可视化图像中类激活的热力图：有助于理解图像的那个部分被识别为属于某个类别，从而可以定位图像的物体—特别用于分类出错的情况</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>实时检测框架，能够快速的检测物体的模型<ul>
<li>faster-RCNN –精准</li>
<li>YOKLO –更快检测</li>
<li>SSD –单发多盒检测器</li>
</ul>
</li>
<li>训练图像的掩膜<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_examples=<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_examples):</span><br><span class="line">   plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">   image=cv2.imread(filename[i])</span><br><span class="line">   image=cv2.cvtColor(image,cv2.COLOR_RGB2RGB)</span><br><span class="line">   plt.imshow(image)</span><br><span class="line"></span><br><span class="line">   plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">   mask_file=filename[i].replace(<span class="string">&#x27;src_color&#x27;</span>,<span class="string">&#x27;human_seg&#x27;</span>)</span><br><span class="line">   mask=cv2.imread(glob.glob(mask_file[:-<span class="number">4</span>]+<span class="string">&#x27;*&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">   ret,mask=cv2.threshold(mask,<span class="number">0.255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">   mask=mask[:<span class="number">0</span>]</span><br><span class="line">   plt.imshow((mask),camp=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure></li>
<li>图像分割分类—U-net</li>
<li>寻找人脸面部关键点</li>
</ol>
<ul>
<li>传统计算机视觉中最常用的应用之一时检测图像中的人脸</li>
<li>第一步检测图像（或帧）中的面部关键点</li>
<li>HOG+线性SVM等传统计算机视觉技术和机器学习技术任然被使用</li>
<li>头部姿态、脸部变形以及使用opencv进行跟踪</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>带有relu的dense层堆叠，可以解决很多种问题（包括情感分析问题）</p>
</li>
<li><p>对于二类问题（两个输出类别），网络的最后一层应该是只有一个单元使用sigmoid激活的dense层，网络输出应该是0-1范围内的标量，表示概率</p>
</li>
<li><p>对于二分类问题的sigmoid标量输出，你应该使用binary_cossesntropy损失函数</p>
</li>
<li><p>无论你的问题是什么，rmsprop优化器通常都是足够号的选择。这一点无须担心。</p>
</li>
<li><p>如果要对n个类别的数据点进行分类，那么最后一层应该是n个dense层</p>
</li>
<li><p>对于单标签。多分类问题，网络的最后一层应该使用softmax函数激活，输出类别的概率分布</p>
</li>
<li><p>处理多分类问题的标签有两种方法</p>
</li>
<li><p>分类编码（one-hot编码）对标签进行编码（y_lables）然后使用categorical_crossentropy作为损失函数<br>将标签编码为整数，然后使用spare_categroical_crossentropy损失函数<br>如果你需要将数据划分到许多分类种，应该避免使用太小的中间层，以免网络中造成信息瓶颈</p>
</li>
<li><p>题使用的损失函数与分类问题不同。回归常用的损失函数是均方差。</p>
</li>
<li><p>归问题使用的评估指标也与分类问题不同，显而易见，精度的概念不适用于回归问题。常见的回归指标是平均绝对误差（mae）</p>
</li>
<li><p>数据的特征具有不同的取值范围，应该先进行预处理，对每个特征单独进行缩放</p>
</li>
<li><p>的数据很少，使用k折验证可以可靠的评估模型</p>
</li>
<li><p>的训练很少，最好使用隐藏层较少（通常只有一到两个的小型网络），以避免过拟合</p>
</li>
<li><p>评估模型注意点</p>
<ul>
<li>数据代表性–随机打乱数据</li>
<li>时间箭头–不可打乱数据，测试机的时间晚于训练集的数据</li>
<li>数据冗余–训练集和数据集不能有交集</li>
<li>数据标准化–每个特征的取值范围不一致</li>
</ul>
</li>
<li><p>数据必须向量化</p>
</li>
<li><p>处理缺失值–不是所有样本都有这个特征</p>
</li>
<li><p>无法确认模型是否强大–就必须开发过拟合的模型</p>
<ul>
<li>添加更多的层</li>
<li>让每一层变得更大</li>
<li>训练更多的轮次</li>
<li>出现过拟合然后进行优化和调参，监督其参数的变化</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/2024/02/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h1><p>当浏览器的网络线程收到 <code>HTML</code> 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列（如图1）。</p>
<p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p>
<p><img src="/images/browserRender/img_01.png" alt="渲染流程"></p>
<p>整个渲染流程分为多个阶段，分别是： <code>HTML</code> 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p>
<p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p>
<p>这样，整个渲染流程就形成了一套组织严密的生产流水线。<br><img src="/images/browserRender/img_02.png" alt="渲染主线程"></p>
<h2 id="解析-HTML"><a href="#解析-HTML" class="headerlink" title="解析 HTML"></a>解析 <code>HTML</code></h2><p>解析过程中遇到 <code>CSS</code> 解析 <code> CSS</code>，遇到 <code>JS</code> 执行 <code>JS</code>。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 <code>HTML</code> 中的外部 <code>CSS</code> 文件和 外部的 <code>JS</code> 文件。</p>
<p>如果主线程解析到<code>link</code>位置，此时外部的 <code>CSS</code> 文件还没有下载解析好，主线程不会等待，继续解析后续的 <code>HTML</code>。这是因为下载和解析 <code>CSS</code> 的工作是在预解析线程中进行的。这就是 <code>CSS</code> 不会阻塞<code> HTML</code> 解析的根本原因。</p>
<p>如果主线程解析到<code>script</code>位置，会停止解析<code> HTML</code>，转而等待 <code>JS</code> 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 <code>JS</code> 代码的执行过程可能会修改当前的 <code>DOM</code> 树，所以 <code>DOM</code> 树的生成必须暂停。这就是 <code>JS</code> 会阻塞 <code>HTML</code> 解析的根本原因。</p>
<p>第一步完成后，会得到 <code>DOM</code> 树和 <code>CSSOM</code> 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 <code>CSSOM</code> 树中。</p>
<p><img src="/images/browserRender/img_04.png" alt="解析 HTML"></p>
<h2 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h2><p>主线程会遍历得到的 <code>DOM</code> 树，依次为树中的每个节点计算出它最终的样式，称之为 <code>Computed Style</code>。</p>
<p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p>
<p>这一步完成后，会得到一棵带有样式的 <code>DOM</code> 树。<br><img src="/images/browserRender/img_08.png" alt="样式计算"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局阶段会依次遍历 <code>DOM</code> 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p>
<p>大部分时候，<code>DOM</code> 树和布局树并非一一对应。</p>
<p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p>
<p><img src="/images/browserRender/img_09.png" alt="布局"><br><img src="/images/browserRender/img_10.png" alt="移除隐藏元素"><br><img src="/images/browserRender/img_11.png" alt="生成匿名块"></p>
<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p>
<p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p>
<p>滚动条、堆叠上下文、<code>transform</code>、<code>opacity</code> 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。<br><img src="/images/browserRender/img_12.png" alt="分层"></p>
<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p>
<p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p>
<p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p>
<p>它会从线程池中拿取多个线程来完成分块工作。<br><img src="/images/browserRender/img_13.png" alt="绘制"></p>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>合成线程会将块信息交给 <code>GPU</code> 进程，以极高的速度完成光栅化。</p>
<p><code>GPU</code> 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p>
<p>光栅化的结果，就是一块一块的位图<br><img src="/images/browserRender/img_15.png" alt="光栅化"><br><img src="/images/browserRender/img_16.png" alt="光栅化"><br><img src="/images/browserRender/img_18.png" alt="光栅化"><br><img src="/images/browserRender/img_17.png" alt="光栅化"></p>
<h2 id="画"><a href="#画" class="headerlink" title="画"></a>画</h2><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p>
<p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p>
<p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p>
<p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。<br><img src="/images/browserRender/img_19.png" alt="画"></p>
<h1 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h1><p>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 <code>layout</code>。</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 <code>JS</code> 代码全部完成后再进行统一计算。所以，改动属性造成的 <code>reflow</code> 是异步完成的。</p>
<p>也同样因为如此，当 <code>JS</code> 获取布局属性时，就可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定获取属性立即 <code>reflow</code>。<br><img src="/images/browserRender/img_23.png" alt="reflow"></p>
<h1 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h1><p><code>repaint</code> 的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，会引发 <code>repaint</code>。</p>
<p>由于元素的布局信息也属于可见样式，所以 <code>reflow</code> 一定会引起 <code>repaint</code>。<br><img src="/images/browserRender/img_22.png" alt="repaint"></p>
<h1 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h1><p>因为 <code>transform</code> 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「<code>draw</code>」阶段</p>
<p>由于 <code>draw</code> 阶段在合成线程中，所以 <code>transform</code> 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 <code>transform</code> 的变化。<br><img src="/images/browserRender/img_21.png" alt="transform"></p>
]]></content>
  </entry>
</search>
